<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width,initial-scale=1" name="viewport"/>
<title>MCQ Quiz â€” Random Mixed Mode</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
  body.dark { background-color: #1a202c; color: #cbd5e1; }
  button:disabled { opacity: 0.5; cursor: not-allowed; }
  .bookmark-btn { cursor: pointer; font-size: 1.2rem; color: #888; }
  .bookmark-btn.bookmarked { color: #fbbf24; }
  #options-form label { display:block; padding:0.5rem; border:1px solid #e5e7eb; border-radius:0.5rem; cursor:pointer; transition: all 0.25s ease; }
  label.correct { background:#5eaf6c; border-color:#16a34a; }
  label.wrong { background:#7f3131; border-color:#dc2626; }
  @keyframes pulse {0%{transform:scale(1)}50%{transform:scale(1.03)}100%{transform:scale(1)}}
  .pulse{animation:pulse .38s ease}
  @keyframes shake {0%{transform:translateX(0)}20%{transform:translateX(-6px)}40%{transform:translateX(6px)}60%{transform:translateX(-4px)}80%{transform:translateX(4px)}100%{transform:translateX(0)}}
  .shake{animation:shake .42s ease}
  #question-container{transition:transform .4s ease, opacity .4s ease}
  .slide-out-left{transform:translateX(-100%);opacity:0}
  .start-off-right{transform:translateX(100%);opacity:0}
  .slide-in-right{transform:translateX(0);opacity:1}
  .overlay { position: fixed; inset:0; background: rgba(0,0,0,0.5); display:flex; align-items:center; justify-content:center; z-index:50; }
  .modal { background: var(--tw-bg-opacity, #fff); padding:1rem; border-radius:0.5rem; width:640px; max-width:95%; }
  /* Mixed panel styles */
  .mixed-panel { border:1px dashed #cbd5e1; padding:0.75rem; border-radius:0.5rem; background:rgba(99,102,241,0.04); }
  .badge { background:#f97316; color:white; padding:0.15rem 0.5rem; border-radius:0.25rem; font-size:0.9rem; }
</style>
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" rel="stylesheet"/><style>
/* New Theme & UI Enhancements */
body {
    background-color: #f8f9fa;
    font-family: Arial, sans-serif;
    margin: 0;
    padding: 0;
}
button {
    border-radius: 8px;
    border: none;
    padding: 8px 14px;
    cursor: pointer;
    font-weight: bold;
    transition: all 0.2s ease;
}
button:hover {
    transform: scale(1.05);
    opacity: 0.9;
}
button:active {
    transform: scale(0.95);
}
.panel, .modal, .quiz-section {
    border-radius: 12px;
    box-shadow: 0 4px 8px rgba(0,0,0,0.1);
}
/* Progress bar */
#progress-bar {
    height: 8px;
    background: #ddd;
    border-radius: 4px;
    margin-bottom: 10px;
}
#progress-fill {
    height: 100%;
    background: #28a745;
    width: 0%;
    transition: width 0.3s ease;
    border-radius: 4px;
}
/* Answer feedback animations */
.option.correct {
    animation: correctFlash 0.5s;
}
.option.wrong {
    animation: wrongShake 0.4s;
}
@keyframes correctFlash {
    from { background-color: #d4edda; }
    to { background-color: transparent; }
}
@keyframes wrongShake {
    0%,100% { transform: translateX(0); }
    25% { transform: translateX(-4px); }
    75% { transform: translateX(4px); }
}
/* Mobile */
@media (max-width: 600px) {
    button, .option {
        width: 100%;
        box-sizing: border-box;
    }
}
</style><style>
/* Data Tools responsive */
#manage-bank-panel .px-3 { }
@media (max-width: 640px) {
  #manage-bank-panel .px-3, #manage-bank-panel .px-4 {
    width: 100% !important;
  }
  #flex-import-btn, #backup-btn { width: 100% !important; display:block; }
}
/* Toast styling */
#toast-container {
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  bottom: 24px;
  z-index: 9999;
  display: flex;
  flex-direction: column;
  gap: 8px;
  align-items: center;
}
.toast {
  min-width: 220px;
  max-width: 90%;
  padding: 10px 14px;
  border-radius: 8px;
  color: white;
  font-weight: 600;
  box-shadow: 0 6px 18px rgba(0,0,0,0.12);
  opacity: 0.98;
}
.toast.success { background: #16a34a; }
.toast.info { background: #2563eb; }
.toast.warn { background: #f59e0b; color: #000; }
/* Progress bar placement */
#progress-bar { margin-top:8px; margin-bottom:12px; }
#progress-fill { transition: width 0.25s ease, background 0.25s ease; }
</style>
<!-- Google Drive Sync (OAuth) -->
<script src="https://accounts.google.com/gsi/client" async defer></script>

</head>
<body class="min-h-screen p-6 bg-gray-50 dark:bg-gray-900 text-gray-800 dark:text-gray-100 flex flex-col items-center">
<h1 class="text-3xl font-bold mb-6" style="font-size:75%;">MCQ Quiz Practice App â€” Random Mixed</h1>
<div class="mb-6" id="theme-toggle">
<button class="px-4 py-2 bg-blue-600 text-white rounded" id="toggle-theme">Toggle Dark/Light Mode</button>
</div>
<div class="w-full max-w-5xl space-y-6" id="setup">
<!-- Manage Questions / Create -->
<section class="border rounded p-4 bg-white dark:bg-gray-800 shadow">
<div class="flex justify-between items-center mb-3">
<h2 class="text-2xl font-semibold">Manage Questions</h2>
<div class="flex items-center gap-2">
<button class="px-3 py-1 bg-purple-600 text-white rounded" id="toggle-manage-bank">Manage Question Bank</button>
        
</div>
</div>
<!-- Add / Update Form -->
<form class="space-y-3" id="mcq-form">
<input id="edit-id" type="hidden"/>
<div class="grid grid-cols-4 gap-3">
<div>
<label class="block mb-1">Main</label>
<input class="w-full p-2 border rounded" id="main-input" list="main-list" placeholder="e.g., Biology" required="" type="text"/>
<datalist id="main-list"></datalist>
</div>
<div>
<label class="block mb-1">Class</label>
<input class="w-full p-2 border rounded" id="class-input" list="class-list" placeholder="e.g., 10th Class" required="" type="text"/>
<datalist id="class-list"></datalist>
</div>
<div>
<label class="block mb-1">Chapter</label>
<input class="w-full p-2 border rounded" id="chapter-input" list="chapter-list" placeholder="e.g., Chapter 1" required="" type="text"/>
<datalist id="chapter-list"></datalist>
</div>
<div>
<label class="block mb-1">Set</label>
<input class="w-full p-2 border rounded" id="set-input" list="set-list" placeholder="e.g., Set 1" required="" type="text"/>
<datalist id="set-list"></datalist>
</div>
</div>
<div class="grid grid-cols-3 gap-3">
<div>
<label class="block mb-1">Difficulty</label>
<select class="w-full p-2 border rounded" id="difficulty" required="">
<option disabled="" selected="" value="">Select</option>
<option value="easy">Easy</option>
<option value="medium">Medium</option>
<option value="hard">Hard</option>
</select>
</div>
<div class="col-span-2">
<label class="block mb-1">Question</label>
<input class="w-full p-2 border rounded" id="question-text" placeholder="Enter question text" required="" type="text"/>
</div>
</div>
<div>
<label class="block mb-1">Options (mark correct)</label>
<div class="grid grid-cols-2 gap-2 items-center">
<input class="p-2 border rounded" id="option0" placeholder="Option 1" required="" type="text"/>
<input name="correct" required="" type="radio" value="0"/>
<input class="p-2 border rounded" id="option1" placeholder="Option 2" required="" type="text"/>
<input name="correct" type="radio" value="1"/>
<input class="p-2 border rounded" id="option2" placeholder="Option 3" required="" type="text"/>
<input name="correct" type="radio" value="2"/>
<input class="p-2 border rounded" id="option3" placeholder="Option 4" required="" type="text"/>
<input name="correct" type="radio" value="3"/>
</div>
</div>
<div class="flex gap-2">
<button class="px-4 py-2 bg-green-600 text-white rounded" type="submit">Add / Update Question</button>
<button class="px-4 py-2 bg-gray-600 text-white rounded" id="clear-form" type="button">Clear</button>
</div>
</form>
<!-- Manage Bank Panel (hidden by default) -->
<div class="mt-4 hidden border-t pt-4" id="manage-bank-panel"><div class="mb-3"><div class="flex items-center justify-between mb-2"><div class="font-semibold text-lg">ðŸ“‚ Data Tools</div></div><div class="flex gap-2 mb-3" style="flex-wrap:wrap;"><button class="px-3 py-2 bg-blue-600 text-white rounded" id="flex-import-btn">ðŸ“¥ Flexible Import</button><button class="px-3 py-2 bg-green-600 text-white rounded" id="backup-btn">ðŸ’¾ Backup Now</button></div></div>
<div class="flex justify-between items-center mb-3">
<div class="flex items-center gap-3">
<input class="p-2 border rounded w-96" id="manage-search" placeholder="Search questions (text/difficulty)" type="search"/>
<button class="px-3 py-1 bg-indigo-500 text-white rounded" id="refresh-manage">Refresh</button>
</div>
<div>

<button class="px-3 py-1 bg-indigo-600 text-white rounded mr-2" id="export-bank">Export All JSON</button>
<button class="px-3 py-1 bg-blue-600 text-white rounded mr-2" id="import-bank">Import JSON</button>

<!-- Google Drive Sync Buttons -->
<button class="px-3 py-1 bg-emerald-600 text-white rounded mr-2" id="gdrive-signin">Google Login</button>
<button class="px-3 py-1 bg-emerald-700 text-white rounded mr-2" id="gdrive-upload">â¬† Upload to Drive</button>
<button class="px-3 py-1 bg-emerald-800 text-white rounded" id="gdrive-download">â¬‡ Download from Drive</button>

</div>
</div>
<div class="space-y-3" id="manage-categories"></div>
<p class="text-sm text-gray-500 mt-3">Tip: Edit loads the item into the form at top. Deleting updates bookmarks/weak/progress automatically.</p>
</div>
</section>
<!-- Import/Export Quick area -->
<section class="border rounded p-4 bg-white dark:bg-gray-800 shadow">
<h2 class="text-2xl font-semibold mb-3">Import / Export (Quick)</h2>
<textarea class="w-full p-2 border rounded dark:bg-gray-700 dark:text-gray-100" id="import-export-area" placeholder="Paste JSON for import or export area" rows="6"></textarea>
<div class="mt-2 flex gap-2">
<button class="px-4 py-2 bg-blue-600 text-white rounded" id="import-btn">Import JSON (legacy)</button>
<button class="px-4 py-2 bg-indigo-600 text-white rounded" id="export-btn">Export JSON</button>
<button class="px-4 py-2 bg-red-600 text-white rounded" id="reset-btn">Reset All Data</button>
</div>
</section>
<!-- Quiz Setup -->
<section class="border rounded p-4 bg-white dark:bg-gray-800 shadow">
<h2 class="text-2xl font-semibold mb-3">Quiz Setup</h2>
<div class="grid grid-cols-4 gap-3 items-end">
<div>
<label class="block mb-1">Main</label>
<select class="w-full p-2 border rounded" id="quiz-main"></select>
</div>
<div>
<label class="block mb-1">Class</label>
<select class="w-full p-2 border rounded" id="quiz-class"></select>
</div>
<div>
<label class="block mb-1">Chapter</label>
<select class="w-full p-2 border rounded" id="quiz-chapter"></select>
</div>
<div>
<label class="block mb-1">Set</label>
<select class="w-full p-2 border rounded" id="quiz-set"></select>
</div>
</div>
<div class="grid grid-cols-3 gap-4 items-end mt-3">
<div>
<label class="block mb-1">Select Mode</label>
<select class="w-full p-2 border rounded" id="quiz-mode">
<option value="normal">Practice All</option>
<option value="weak">Practice Weak Areas</option>
<option value="adaptive">Adaptive Difficulty</option>
<option value="bookmarked">Practice Bookmarked</option>
<option value="random_mixed">Random Mixed</option>
</select>
</div>
<div class="col-span-2">
<button class="w-full px-4 py-2 bg-blue-700 text-white rounded" id="start-quiz">Start Quiz</button>
</div>
</div>
<!-- Random Mixed Set Selection Panel (hidden until mode chosen) -->
<div class="mt-4 hidden" id="mixed-selection-panel">
<h3 class="text-lg font-semibold mb-2">Select Sets for Random Mixed Mode</h3>
<p class="text-sm text-gray-600 mb-2">Pick one or more sets; Start will be enabled once at least one set is selected. Selection resets each time you enter Random Mixed.</p>
<div class="mixed-panel space-y-2 max-h-72 overflow-auto p-2" id="mixed-sets-container"></div>
</div>
</section>
</div>
<!-- Quiz & Results sections -->
<div class="hidden w-full max-w-5xl mt-6 bg-white dark:bg-gray-800 p-6 rounded shadow space-y-4" id="quiz-section">
<div class="flex justify-between items-center">
<h2 class="text-xl font-semibold">Quiz <span id="mode-badge-holder"></span></h2>
<button class="text-red-600 hover:underline" id="cancel-quiz">Cancel</button>
</div>
<div>
<p class="font-medium">Category: <span id="quiz-cat-display"></span> | Mode: <span id="quiz-mode-display"></span></p>
<p class="font-medium">Progress: <span id="quiz-progress"></span></p>
</div>
<div class="w-full bg-gray-200 rounded" id="progress-bar"><div id="progress-fill" style="width:0%; height:8px; background:#28a745; border-radius:4px;"></div></div><div id="question-container">
<div class="flex justify-between items-center mt-2">
<div class="text-lg font-semibold" id="question-area"></div>
<div>
<button class="bookmark-btn" id="bookmark-toggle" title="Bookmark">â˜†</button>
</div>
</div>
<form class="space-y-2" id="options-form"></form>
</div>
<div class="flex justify-between mt-4">
<button class="px-4 py-2 bg-gray-300 rounded disabled:opacity-50" disabled="" id="prev-question">Previous</button>
<button class="px-4 py-2 bg-gray-300 rounded disabled:opacity-50" disabled="" id="next-question">Next</button>
</div>
</div>
<div class="hidden w-full max-w-5xl mt-6 bg-white dark:bg-gray-800 p-6 rounded shadow space-y-4" id="results-section">
<h2 class="text-2xl font-bold">Quiz Results</h2>
<div id="results-summary"></div>
<button class="w-full py-2 bg-yellow-500 text-white rounded" id="practice-weak">Practice Weak Areas</button>
<button class="w-full py-2 bg-gray-600 text-white rounded" id="back-to-setup">Back to Setup</button>
</div>
<!-- Import placement overlay (hidden by default) -->
<div aria-hidden="true" class="overlay hidden" id="import-placement-overlay">
<div class="modal bg-white dark:bg-gray-800">
<h3 class="text-xl font-semibold mb-3">Import Questions â€” Select Destination</h3>
<div class="grid grid-cols-2 gap-3 mb-3">
<div>
<label class="block mb-1">Main</label>
<input class="w-full p-2 border rounded" id="imp-main" list="imp-main-list" placeholder="Enter main category"/>
<datalist id="imp-main-list"></datalist>
</div>
<div>
<label class="block mb-1">Class</label>
<input class="w-full p-2 border rounded" id="imp-class" list="imp-class-list" placeholder="Enter class"/>
<datalist id="imp-class-list"></datalist>
</div>
<div>
<label class="block mb-1">Chapter</label>
<input class="w-full p-2 border rounded" id="imp-chapter" list="imp-chapter-list" placeholder="Enter chapter"/>
<datalist id="imp-chapter-list"></datalist>
</div>
<div>
<label class="block mb-1">Set</label>
<input class="w-full p-2 border rounded" id="imp-set" list="imp-set-list" placeholder="Enter set"/>
<datalist id="imp-set-list"></datalist>
</div>
</div>
<div class="flex justify-end gap-2">
<button class="px-3 py-1 bg-gray-400 text-white rounded" id="imp-cancel">Cancel</button>
<button class="px-3 py-1 bg-blue-600 text-white rounded" id="imp-confirm">Confirm Import Here</button>
</div>
</div>
</div>
<!-- Export placement overlay (adds category/subcategory export) -->
<div aria-hidden="true" class="overlay hidden" id="export-overlay">
<div class="modal bg-white dark:bg-gray-800">
<h3 class="text-xl font-semibold mb-3">Export Questions â€” Choose Scope</h3>
<div class="grid grid-cols-2 gap-3 mb-3">
<div>
<label class="block mb-1">Main</label>
<select class="w-full p-2 border rounded" id="exp-main"></select>
</div>
<div>
<label class="block mb-1">Class</label>
<select class="w-full p-2 border rounded" id="exp-class"></select>
</div>
<div>
<label class="block mb-1">Chapter</label>
<select class="w-full p-2 border rounded" id="exp-chapter"></select>
</div>
<div>
<label class="block mb-1">Set</label>
<select class="w-full p-2 border rounded" id="exp-set"></select>
</div>
</div>
<div class="flex justify-end gap-2">
<button class="px-3 py-1 bg-blue-600 text-white rounded" id="exp-all">Export All</button>
<button class="px-3 py-1 bg-green-600 text-white rounded" id="exp-selected">Export Selected</button>
<button class="px-3 py-1 bg-yellow-500 text-white rounded" id="exp-branch">Export Branch</button>
<button class="px-3 py-1 bg-gray-400 text-white rounded" id="exp-cancel">Cancel</button>
</div>
</div>
</div>

<script>
(() => {
  /* -------------------------
     Utilities & Storage
     ------------------------- */
  // debounce helper for search inputs to avoid re-rendering too often
  function debounce(fn, wait){ let t; return function(...args){ clearTimeout(t); t = setTimeout(()=>fn.apply(this,args), wait); }; }

  const PATH_SEP = '||';
  function pathKey(main, cls, chap, set) { return [main||'', cls||'', chap||'', set||''].join(PATH_SEP); }
  function splitKey(key) {
    const parts = String(key||'').split(PATH_SEP);
    return { main: parts[0]||'', cls: parts[1]||'', chap: parts[2]||'', set: parts[3]||'' };
  }

  function saveToStorage() {
    localStorage.setItem('mcqQuestions', JSON.stringify(questionBank));
    localStorage.setItem('mcqWeak', JSON.stringify(weakQuestions));
    localStorage.setItem('mcqProgress', JSON.stringify(progressData));
    localStorage.setItem('mcqBookmarks', JSON.stringify(bookmarkedQuestions));
    localStorage.setItem('mcqTheme', document.body.classList.contains('dark') ? 'dark' : 'light');
  }

  function loadFromStorage() {
    try {
      const raw = localStorage.getItem('mcqQuestions');
      if(!raw) return;
      const parsed = JSON.parse(raw);
      if(!parsed) return;
      for(const k in parsed) {
        const val = parsed[k];
        if(Array.isArray(val)) {
          if(k.indexOf(PATH_SEP) !== -1) {
            questionBank[k] = val;
          } else {
            const newKey = pathKey(k, 'General', 'General', 'Default');
            questionBank[newKey] = questionBank[newKey] || [];
            val.forEach(q => {
              if(!q.id) q.id = generateId();
              q.category = newKey;
              questionBank[newKey].push(q);
            });
          }
        }
      }
    } catch(e) {}
    try { const w = JSON.parse(localStorage.getItem('mcqWeak')); if(w) Object.assign(weakQuestions, w); } catch(e){}
    try { const p = JSON.parse(localStorage.getItem('mcqProgress')); if(p) Object.assign(progressData, p); } catch(e){}
    try { const b = JSON.parse(localStorage.getItem('mcqBookmarks')); if(b) Object.assign(bookmarkedQuestions, b); } catch(e){}
  }

  function generateId() { return 'q_' + Math.random().toString(36).slice(2,9); }
  function shuffleArray(arr) { for(let i=arr.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[arr[i],arr[j]]=[arr[j],arr[i]];} }

  /* -------------------------
     App State
     ------------------------- */
  const questionBank = {}; const weakQuestions = {}; const progressData = {}; const bookmarkedQuestions = {};
  let currentCategoryKey = null; let currentMode = null; let questionsToPractice = []; let currentQuestionIndex = 0;
  let userAnswers = {}; let isAnimating = false; let inRepractice = false;

  /* -------------------------
     Live-sync helpers: keep running quiz pool updated on edit/delete
     ------------------------- */
  function syncDeleteFromActiveQuiz(qid) {
    try {
      if(!Array.isArray(questionsToPractice) || questionsToPractice.length===0) return;
      const idx = questionsToPractice.findIndex(q=>q.id===qid);
      if(idx===-1) return;
      questionsToPractice.splice(idx,1);
      if(idx < currentQuestionIndex) currentQuestionIndex = Math.max(0, currentQuestionIndex-1);
      if(questionsToPractice.length===0) { endQuiz(); return; }
      if(currentQuestionIndex >= questionsToPractice.length) currentQuestionIndex = questionsToPractice.length-1;
      showQuestion(currentQuestionIndex);
    } catch(e) { console.warn('syncDeleteFromActiveQuiz failed', e); }
  }

  function syncEditToActiveQuiz(editId, editedObj) {
    try {
      if(!editId || !Array.isArray(questionsToPractice) || questionsToPractice.length===0) return;
      for(let i=0;i<questionsToPractice.length;i++){
        if(questionsToPractice[i].id===editId){
          questionsToPractice[i] = Object.assign({}, editedObj);
          if(i===currentQuestionIndex){ showQuestion(currentQuestionIndex); }
          break;
        }
      }
    } catch(e){ console.warn('syncEditToActiveQuiz failed', e); }
  }


  /* -------------------------
     Elements
     ------------------------- */
  const mainInput = document.getElementById('main-input'), classInput = document.getElementById('class-input'),
        chapterInput = document.getElementById('chapter-input'), setInput = document.getElementById('set-input');
  const mainList = document.getElementById('main-list'), classList = document.getElementById('class-list'),
        chapterList = document.getElementById('chapter-list'), setList = document.getElementById('set-list');

  const difficultyInput = document.getElementById('difficulty'), questionInput = document.getElementById('question-text'),
        optionInputs = [document.getElementById('option0'),document.getElementById('option1'),document.getElementById('option2'),document.getElementById('option3')],
        mcqForm = document.getElementById('mcq-form'), clearFormBtn = document.getElementById('clear-form');

  const importExportArea = document.getElementById('import-export-area'), importBtn = document.getElementById('import-btn'),
        exportBtn = document.getElementById('export-btn'), resetBtn = document.getElementById('reset-btn');

  const quizMain = document.getElementById('quiz-main'), quizClass = document.getElementById('quiz-class'),
        quizChapter = document.getElementById('quiz-chapter'), quizSet = document.getElementById('quiz-set'),
        quizModeSelect = document.getElementById('quiz-mode'), startQuizBtn = document.getElementById('start-quiz');

  const setupSection = document.getElementById('setup'), quizSection = document.getElementById('quiz-section'),
        resultsSection = document.getElementById('results-section');

  const quizCatDisplay = document.getElementById('quiz-cat-display'), quizModeDisplay = document.getElementById('quiz-mode-display'),
        quizProgress = document.getElementById('quiz-progress'), questionArea = document.getElementById('question-area'),
        optionsForm = document.getElementById('options-form');

  const prevQuestionBtn = document.getElementById('prev-question'), nextQuestionBtn = document.getElementById('next-question'),
        cancelQuizBtn = document.getElementById('cancel-quiz');

  const resultsSummary = document.getElementById('results-summary'), practiceWeakBtn = document.getElementById('practice-weak'),
        backToSetupBtn = document.getElementById('back-to-setup');

  const toggleThemeBtn = document.getElementById('toggle-theme'), bookmarkToggleBtn = document.getElementById('bookmark-toggle'),
        questionContainer = document.getElementById('question-container');

  const toggleManageBankBtn = document.getElementById('toggle-manage-bank'), manageBankPanel = document.getElementById('manage-bank-panel'),
        manageCategoriesDiv = document.getElementById('manage-categories'), manageSearch = document.getElementById('manage-search'),
        refreshManageBtn = document.getElementById('refresh-manage'), exportBankBtn = document.getElementById('export-bank'),
        importBankBtn = document.getElementById('import-bank');

  const mixedPanel = document.getElementById('mixed-selection-panel'), mixedSetsContainer = document.getElementById('mixed-sets-container'),
        modeBadgeHolder = document.getElementById('mode-badge-holder');

  const impOverlay = document.getElementById('import-placement-overlay'), impMain = document.getElementById('imp-main'),
        impClass = document.getElementById('imp-class'), impChapter = document.getElementById('imp-chapter'),
        impSet = document.getElementById('imp-set'), impMainList = document.getElementById('imp-main-list'),
        impClassList = document.getElementById('imp-class-list'), impChapterList = document.getElementById('imp-chapter-list'),
        impSetList = document.getElementById('imp-set-list'), impCancel = document.getElementById('imp-cancel'),
        impConfirm = document.getElementById('imp-confirm');

  /* -------------------------
     Theme
     ------------------------- */
  function loadTheme() { if(localStorage.getItem('mcqTheme')==='dark') document.body.classList.add('dark'); else document.body.classList.remove('dark'); }
  toggleThemeBtn.addEventListener('click', ()=>{ document.body.classList.toggle('dark'); localStorage.setItem('mcqTheme', document.body.classList.contains('dark') ? 'dark':'light'); });

  

/* -------------------------
   Manage Form Popup Helpers (move only #mcq-form)
   ------------------------- */
(function(){
  const popupOverlayId = 'manage-popup-overlay';
  const popupHostId = 'manage-popup-host';
  const popupCloseId = 'manage-popup-close';
  let originalFormParent = null;
  let originalFormNext = null;
  let formMoved = false;

  function openManageInPopup() {
    const overlay = document.getElementById('manage-popup-overlay');
    const host = document.getElementById('manage-popup-host');
    const mcqForm = document.getElementById('mcq-form');
    if(!overlay || !host || !mcqForm) return false;

    // Save original position
    if(!formMoved) {
      originalFormParent = mcqForm.parentNode;
      originalFormNext = mcqForm.nextSibling;
    }
    // Move form into host (and ensure it's visible)
    host.appendChild(mcqForm);
    mcqForm.classList.remove('hidden');
    overlay.classList.remove('hidden');
    formMoved = true;

    // focus first input in form
    const firstInput = mcqForm.querySelector('input, textarea, select, button');
    if(firstInput) try{ firstInput.focus(); }catch(e){}
    return true;
  }

  function closeManagePopup() {
    const overlay = document.getElementById('manage-popup-overlay');
    const host = document.getElementById('manage-popup-host');
    const mcqForm = document.getElementById('mcq-form');
    if(!overlay || !host || !mcqForm) return false;

    // Move back to original location
    if(formMoved && originalFormParent) {
      if(originalFormNext) originalFormParent.insertBefore(mcqForm, originalFormNext);
      else originalFormParent.appendChild(mcqForm);
    }
    // hide overlay
    overlay.classList.add('hidden');
    formMoved = false;
    return true;
  }

  // expose globally so other handlers can call it
  window.openManageInPopup = openManageInPopup;
  window.closeManagePopup = closeManagePopup;

  // close button handler
  document.addEventListener('DOMContentLoaded', ()=> {
    const closeBtn = document.getElementById(popupCloseId);
    const overlay = document.getElementById('manage-popup-overlay');
    if(closeBtn) closeBtn.addEventListener('click', ()=> { closeManagePopup(); });
    // close on ESC
    document.addEventListener('keydown', (e)=> { if(e.key==='Escape') { if(overlay && !overlay.classList.contains('hidden')) closeManagePopup(); } });
    // clicking outside modal content should close
    if(overlay) overlay.addEventListener('click', (ev)=> {
      if(ev.target === overlay) closeManagePopup();
    });
  });
})();

;

/* -------------------------
     Build index tree from questionBank
     ------------------------- */
  function buildPathsIndex() {
    const tree = {}
  /* -------------------------
     Counts for dropdown options
     ------------------------- */
  
  

;
    for(const key in questionBank) {
      const p = splitKey(key);
      const m = p.main || 'Uncategorized', c = p.cls || 'General', ch = p.chap || 'General', s = p.set || 'Default';
      tree[m] = tree[m] || {};
      tree[m][c] = tree[m][c] || {};
      tree[m][c][ch] = tree[m][c][ch] || {};
      tree[m][c][ch][s] = questionBank[key].length;
    }
    return tree;
  }

  /* Counts for dropdown options (moved outside buildPathsIndex) */
function updateSelectWithCounts(selectEl, level, selMain, selClass, selChap) {
    // normalize undefined -> empty string for easier checks
    selMain = selMain || '';
    selClass = selClass || '';
    selChap = selChap || '';
    Array.from(selectEl.options).forEach(opt => {
      if (!opt.value) return; // skip placeholder option
      let count = 0;
      for (const k in questionBank) {
        const p = splitKey(k);
        // Main level: exact main match
        if (level === 'main') {
          if (p.main === opt.value) count += questionBank[k].length;
        }
        // Class level: if selMain provided, require both main + class; otherwise count class across all mains
        else if (level === 'class') {
          if (selMain) {
            if (p.main === selMain && p.cls === opt.value) count += questionBank[k].length;
          } else {
            if (p.cls === opt.value) count += questionBank[k].length;
          }
        }
        // Chapter level: respect available selectors; narrow down as many as provided
        else if (level === 'chapter') {
          if (selMain && selClass) {
            if (p.main === selMain && p.cls === selClass && p.chap === opt.value) count += questionBank[k].length;
          } else if (selMain) {
            if (p.main === selMain && p.chap === opt.value) count += questionBank[k].length;
          } else if (selClass) {
            if (p.cls === selClass && p.chap === opt.value) count += questionBank[k].length;
          } else {
            if (p.chap === opt.value) count += questionBank[k].length;
          }
        }
        // Set level: match set name and apply any provided prefix filters
        else if (level === 'set') {
          if (p.set !== opt.value) continue;
          if (selMain && p.main !== selMain) continue;
          if (selClass && p.cls !== selClass) continue;
          if (selChap && p.chap !== selChap) continue;
          count += questionBank[k].length;
        }
      }
      opt.textContent = `${opt.value} (${count})`;
      opt.style.color = count === 0 ? '#999' : '';
    });
  }

  function fillDatalistsAndQuizSelectors() {
    const tree = buildPathsIndex();
    mainList.innerHTML=''; classList.innerHTML=''; chapterList.innerHTML=''; setList.innerHTML='';
    impMainList.innerHTML=''; impClassList.innerHTML=''; impChapterList.innerHTML=''; impSetList.innerHTML='';
    quizMain.innerHTML = '<option value="">Select Main</option>';
    Object.keys(tree).sort().forEach(m => { mainList.appendChild(new Option(m)); impMainList.appendChild(new Option(m)); quizMain.appendChild(new Option(m,m)); });
    updateSelectWithCounts(quizMain, 'main');

    const classesSet = new Set(), chaptersSet = new Set(), setsSet = new Set();
    for(const m in tree) {
      for(const c in tree[m]) classesSet.add(c);
      for(const c in tree[m]) {
        for(const ch in tree[m][c]) chaptersSet.add(ch);
        for(const ch in tree[m][c]) for(const s in tree[m][c][ch]) setsSet.add(s);
      }
    }
    classList.innerHTML=''; chapterList.innerHTML=''; setList.innerHTML='';
    classesSet.forEach(c=> classList.appendChild(new Option(c)));
    chaptersSet.forEach(ch=> chapterList.appendChild(new Option(ch)));
    setsSet.forEach(s=> setList.appendChild(new Option(s)));

    impClassList.innerHTML=''; impChapterList.innerHTML=''; impSetList.innerHTML='';
    classesSet.forEach(c=> impClassList.appendChild(new Option(c)));
    chaptersSet.forEach(ch=> impChapterList.appendChild(new Option(ch)));
    setsSet.forEach(s=> impSetList.appendChild(new Option(s)));

    // reset lower selects
    quizClass.innerHTML = '<option value="">Select Class</option>';
    quizChapter.innerHTML = '<option value="">Select Chapter</option>';
    quizSet.innerHTML = '<option value="">Select Set</option>';
  }

  function populateQuizCascadesForMain(selectedMain) {
    quizClass.innerHTML = '<option value="">Select Class</option>';
    quizChapter.innerHTML = '<option value="">Select Chapter</option>';
    quizSet.innerHTML = '<option value="">Select Set</option>';
    const tree = buildPathsIndex();
    if(!selectedMain || !tree[selectedMain]) return;
    Object.keys(tree[selectedMain]).sort().forEach(c => quizClass.appendChild(new Option(c,c)));
    updateSelectWithCounts(quizClass, 'class', quizMain.value);
  }
  function populateQuizCascadesForClass(selectedMain, selectedClass) {
    quizChapter.innerHTML = '<option value="">Select Chapter</option>';
    quizSet.innerHTML = '<option value="">Select Set</option>';
    const tree = buildPathsIndex();
    if(!selectedMain || !selectedClass || !tree[selectedMain] || !tree[selectedMain][selectedClass]) return;
    Object.keys(tree[selectedMain][selectedClass]).sort().forEach(ch => quizChapter.appendChild(new Option(ch,ch)));
    updateSelectWithCounts(quizChapter, 'chapter', quizMain.value, quizClass.value);
  }
  function populateQuizCascadesForChapter(selectedMain, selectedClass, selectedChapter) {
    quizSet.innerHTML = '<option value="">Select Set</option>';
    const tree = buildPathsIndex();
    if(!selectedMain || !selectedClass || !selectedChapter || !tree[selectedMain] || !tree[selectedMain][selectedClass] || !tree[selectedMain][selectedClass][selectedChapter]) return;
    Object.keys(tree[selectedMain][selectedClass][selectedChapter]).sort().forEach(s => quizSet.appendChild(new Option(s,s)));
    updateSelectWithCounts(quizSet, 'set', quizMain.value, quizClass.value, quizChapter.value);
  }

  /* -------------------------
     Add/Edit Question form logic
     ------------------------- */
  function resetForm() { mcqForm.reset(); document.getElementById('edit-id').value=''; }
  mcqForm.addEventListener('submit', e => {
    e.preventDefault();
    const main = mainInput.value.trim(), cls = classInput.value.trim(), chap = chapterInput.value.trim(), setv = setInput.value.trim();
    const difficulty = difficultyInput.value, qtext = questionInput.value.trim();
    const opts = optionInputs.map(i=>i.value.trim());
    const correctRad = mcqForm.correct.value;
    if(!main||!cls||!chap||!setv||!difficulty||!qtext||opts.some(x=>x==='')||correctRad===undefined) { alert('Please fill all fields correctly.'); return; }
    const correct = parseInt(correctRad,10);
    const key = pathKey(main,cls,chap,setv);
    if(!questionBank[key]) questionBank[key]=[];
    let editId = document.getElementById('edit-id').value;
    if(editId) {
      let found=false;
      for(const k in questionBank) {
        const idx = questionBank[k].findIndex(q=>q.id===editId);
        if(idx!==-1) {
          if(k===key) {
            questionBank[k][idx] = { id: editId, category: key, difficulty, question: qtext, options: opts, answer: correct };
          } else {
            questionBank[k].splice(idx,1);
            questionBank[key].push({ id: editId, category: key, difficulty, question: qtext, options: opts, answer: correct });
            if(questionBank[k].length===0) { delete questionBank[k]; delete weakQuestions[k]; delete bookmarkedQuestions[k]; if(progressData[k]) delete progressData[k]; }
          }
          found=true; break;
        }
      }
      if(!found) questionBank[key].push({ id: editId, category: key, difficulty, question: qtext, options: opts, answer: correct });
      try { if(editId){ syncEditToActiveQuiz(editId, { id: editId, category: key, difficulty: difficulty, question: qtext, options: opts, answer: correct }); } } catch(e){ console.warn('sync call failed', e); }

    } else {
      questionBank[key].push({ id: generateId(), category: key, difficulty, question: qtext, options: opts, answer: correct });
    }
    saveToStorage(); resetForm(); buildUIAfterDataChange();
    // ensure visible question list for this set is updated after UI rebuild
    setTimeout(()=>{
      try {
        const sel = document.querySelector('[data-key="'+key+'"]');
        if(sel) renderQuestionsInSet(main, cls, chap, setv, sel, manageSearch.value.trim());
      } catch(e) { console.warn('update visible qlist failed', e); }
    }, 120);
    alert('Question saved.');
  });
  clearFormBtn.addEventListener('click', resetForm);

  /* -------------------------
     Legacy Import quick
     ------------------------- */
  importBtn.addEventListener('click', ()=> {
    try {
      const data = JSON.parse(importExportArea.value);
      if(typeof data!=='object') throw new Error('Invalid JSON');
      for(const k in data) {
        const val = data[k];
        if(!Array.isArray(val)) continue;
        if(k.indexOf(PATH_SEP)!==-1) {
          if(!questionBank[k]) questionBank[k]=[];
          val.forEach(q=>{ if(!questionBank[k].some(ex=>ex.id===q.id)){ if(!q.id) q.id = generateId(); q.category = k; questionBank[k].push(q); } });
        } else {
          const newk = pathKey(k,'General','General','Default');
          if(!questionBank[newk]) questionBank[newk]=[];
          val.forEach(q=>{ if(!q.id) q.id=generateId(); q.category=newk; if(!questionBank[newk].some(ex=>ex.id===q.id)) questionBank[newk].push(q); });
        }
      }
      saveToStorage(); syncDeleteFromActiveQuiz(qid); buildUIAfterDataChange(); alert('Import successful (legacy).');
    } catch(e) { alert('Import failed: ' + e.message); }
  });
  exportBtn.addEventListener('click', ()=> { importExportArea.value = JSON.stringify(questionBank,null,2); });
  resetBtn.addEventListener('click', ()=> { if(confirm('Reset all data? This cannot be undone.')){ localStorage.clear(); location.reload(); } });

  /* -------------------------
     Prepare questions for quiz
     ------------------------- */
  function prepareQuestionsByKey(key, mode) {
    if(!questionBank[key]) return [];
    let base = [...questionBank[key]];
    if(mode==='weak') {
      const weakIds = weakQuestions[key] || [];
      base = base.filter(q=>weakIds.includes(q.id));
    } else if(mode==='bookmarked') {
      const b = bookmarkedQuestions[key] || [];
      base = base.filter(q=>b.includes(q.id));
    }
    return base;
  }

  /* -------------------------
     Show question & answer logic
     ------------------------- */
  function createOptionLabel(text,index,correct,selected,disabled) {
    const label = document.createElement('label');
    label.className = 'block p-2 border rounded cursor-pointer';
    label.dataset.index = index;
    if(disabled) {
      if(index===correct) label.classList.add('correct');
      else if(index===selected && selected!==correct) label.classList.add('wrong');
    }
    const input=document.createElement('input'); input.type='radio'; input.name='answer'; input.value=index; input.disabled=disabled;
    if(selected===index) input.checked=true;
    label.appendChild(input); label.appendChild(document.createTextNode(' ' + text));
    return label;
  }

  function showQuestion(index) {
    questionContainer.classList.remove('slide-out-left','slide-in-right','start-off-right');
    const q = questionsToPractice[index];
    quizProgress.textContent = `${index+1} / ${questionsToPractice.length}`;
    
    updateProgressBar(index, questionsToPractice.length);
questionArea.textContent = q.question;
    optionsForm.innerHTML = '';
    const b = bookmarkedQuestions[currentCategoryKey] || [];
    if(b.includes(q.id)) { bookmarkToggleBtn.classList.add('bookmarked'); bookmarkToggleBtn.innerHTML='â˜…'; bookmarkToggleBtn.setAttribute('aria-pressed','true'); }
    else { bookmarkToggleBtn.classList.remove('bookmarked'); bookmarkToggleBtn.innerHTML='â˜†'; bookmarkToggleBtn.setAttribute('aria-pressed','false'); }
    q.options.forEach((opt,i)=> {
      const selected = userAnswers[q.id];
      const correct = q.answer;
      const disabled = selected!==undefined;
      const label = createOptionLabel(opt,i,correct,selected,disabled);
      optionsForm.appendChild(label);
    });
    // --- inline Edit / Delete controls for current quiz question ---
    try {
      // remove existing inline controls
      const existingInline = questionContainer.querySelector('#inline-edit-delete');
      if(existingInline) existingInline.remove();
      const inlineDiv = document.createElement('div');
      inlineDiv.id = 'inline-edit-delete';
      inlineDiv.style.marginTop = '8px';
      inlineDiv.className = 'flex gap-2';
      const editBtn = document.createElement('button');
      editBtn.type = 'button';
      editBtn.className = 'px-2 py-1 bg-blue-500 text-white rounded';
      editBtn.textContent = 'Edit';
      editBtn.title = 'Edit this question (opens edit form)';
      editBtn.addEventListener('click', ()=> {
        try {
          const cur = questionsToPractice[currentQuestionIndex];
          if(!cur) return alert('No current question to edit.');
          // Show Manage Bank Panel as a popup and bring to front
          try { renderManageCategories(manageSearch && manageSearch.value ? manageSearch.value.trim() : ''); } catch(e){ /* ignore */ }

          // Open manage panel inside popup
          try { openManageInPopup(); } catch(e) { if(manageBankPanel) { manageBankPanel.classList.remove('hidden'); } }

          // populate edit form fields
          document.getElementById('edit-id').value = cur.id || '';
          if(typeof mainInput !== 'undefined') { mainInput.value = (cur.category||'').split(PATH_SEP)[0] || ''; }
          if(typeof classInput !== 'undefined') { classInput.value = (cur.category||'').split(PATH_SEP)[1] || ''; }
          if(typeof chapterInput !== 'undefined') { chapterInput.value = (cur.category||'').split(PATH_SEP)[2] || ''; }
          if(typeof setInput !== 'undefined') { setInput.value = (cur.category||'').split(PATH_SEP)[3] || ''; }
          if(typeof difficultySelect !== 'undefined') difficultySelect.value = cur.difficulty || 'easy';
          const qtxt = document.getElementById('question-text');
          if(qtxt) { qtxt.value = cur.question || ''; qtxt.focus(); }
          const optIds = ['option0','option1','option2','option3'];
          optIds.forEach((id,i)=>{ const el=document.getElementById(id); if(el) el.value = (cur.options && cur.options[i]) ? cur.options[i] : ''; });
          const cr = document.querySelectorAll('input[name=\"correct\"]');
          if(cr && cr.length>0){
            cr.forEach(r=>r.checked=false);
            if(typeof cur.answer !== 'undefined' && cr[cur.answer]) cr[cur.answer].checked = true;
          }
        } catch(e){ console.warn('inline edit failed', e); alert('Could not open edit form.'); }
      });
      const delBtn = document.createElement('button');
      delBtn.type = 'button';
      delBtn.className = 'px-2 py-1 bg-red-500 text-white rounded';
      delBtn.textContent = 'Delete';
      delBtn.title = 'Delete this question permanently';
      delBtn.addEventListener('click', ()=> {
        try {
          const cur = questionsToPractice[currentQuestionIndex];
          if(!cur) return alert('No current question to delete.');
          if(!confirm('Delete this question? This cannot be undone.')) return;
          // call existing delete function to remove from bank and storage
          try { deleteQuestion(cur.category, cur.id); } catch(e){ console.warn('deleteQuestion call failed', e); }
          // also ensure active quiz pool sync
          try { syncDeleteFromActiveQuiz(cur.id); } catch(e){ console.warn('syncDelete failed', e); }
        } catch(e){ console.warn('inline delete failed', e); alert('Could not delete question.'); }
      });
      inlineDiv.appendChild(editBtn);
      inlineDiv.appendChild(delBtn);
      // append after optionsForm
      if(optionsForm && optionsForm.parentNode) {
        optionsForm.parentNode.insertBefore(inlineDiv, optionsForm.nextSibling);
      } else {
        questionContainer.appendChild(inlineDiv);
      }
    } catch(e){ console.warn('render inline controls error', e); }

    prevQuestionBtn.disabled = (index===0);
    nextQuestionBtn.disabled = (index===questionsToPractice.length-1);
  }

  bookmarkToggleBtn.addEventListener('click', ()=> {
    const q = questionsToPractice[currentQuestionIndex];
    if(!bookmarkedQuestions[currentCategoryKey]) bookmarkedQuestions[currentCategoryKey]=[];
    const lst = bookmarkedQuestions[currentCategoryKey];
    const idx = lst.indexOf(q.id);
    if(idx===-1) { lst.push(q.id); bookmarkToggleBtn.classList.add('bookmarked'); bookmarkToggleBtn.innerHTML='â˜…'; bookmarkToggleBtn.setAttribute('aria-pressed','true'); }
    else { lst.splice(idx,1); bookmarkToggleBtn.classList.remove('bookmarked'); bookmarkToggleBtn.innerHTML='â˜†'; bookmarkToggleBtn.setAttribute('aria-pressed','false'); }
    saveToStorage();
  });

  function updateProgress(key,difficulty,correct) {
    if(!progressData[key]) progressData[key] = {attempts:0,correct:0,streak:0};
    if(correct) { progressData[key].correct++; progressData[key].streak++; } else { progressData[key].streak = 0; }
    progressData[key].attempts++;
  }

  optionsForm.addEventListener('click', e=> {
    if(isAnimating) return;
    const label = e.target.closest('label');
    if(!label) return;
    const input = label.querySelector('input[name="answer"]');
    if(!input || input.disabled) return;
    input.checked = true;
    triggerAnswerSelection(parseInt(input.value,10));
  });

  function triggerAnswerSelection(selectedIndex) {
    const q = questionsToPractice[currentQuestionIndex];
    if(!q) return;
    if(userAnswers[q.id]!==undefined) return;
    userAnswers[q.id] = selectedIndex;
    let isWrong=false;
    isAnimating=true;
    const labels = optionsForm.querySelectorAll('label');
    labels.forEach((label,idx) => {
      const inp = label.querySelector('input');
      if(inp) inp.disabled=true;
      if(idx===q.answer) { setTimeout(()=>{ label.classList.add('correct'); label.classList.add('pulse'); setTimeout(()=>label.classList.remove('pulse'),420); },50); }
      else if(idx===selectedIndex && selectedIndex!==q.answer) { isWrong=true; setTimeout(()=>{ label.classList.add('wrong'); label.classList.add('shake'); setTimeout(()=>label.classList.remove('shake'),420); },50); }
    });

    const correct = (selectedIndex===q.answer);
    updateProgress(q.category,q.difficulty,correct);
    if(!correct) {
      if(!weakQuestions[q.category]) weakQuestions[q.category]=[];
      if(!weakQuestions[q.category].includes(q.id)) weakQuestions[q.category].push(q.id);
    } else {
      if(weakQuestions[q.category]) {
        const idx = weakQuestions[q.category].indexOf(q.id);
        if(idx!==-1) weakQuestions[q.category].splice(idx,1);
      }
    }
    saveToStorage();

    const delayBeforeSlide = isWrong ? 1800 : 1500;
    setTimeout(()=> {
      questionContainer.classList.add('slide-out-left');
      setTimeout(()=> {
        currentQuestionIndex++;
        if(currentQuestionIndex < questionsToPractice.length) {
          showQuestion(currentQuestionIndex);
          questionContainer.classList.remove('slide-out-left');
          questionContainer.classList.add('start-off-right');
          requestAnimationFrame(()=> {
            questionContainer.classList.remove('start-off-right');
            questionContainer.classList.add('slide-in-right');
            setTimeout(()=> { questionContainer.classList.remove('slide-in-right'); isAnimating=false; }, 420);
          });
        } else {
          isAnimating=false;
          showResults();
        }
      },400);
    }, delayBeforeSlide);
  }

  prevQuestionBtn.addEventListener('click', ()=> { if(isAnimating) return; if(currentQuestionIndex>0){ currentQuestionIndex--; showQuestion(currentQuestionIndex); }});
  nextQuestionBtn.addEventListener('click', ()=> { if(isAnimating) return; if(currentQuestionIndex < questionsToPractice.length-1){ currentQuestionIndex++; showQuestion(currentQuestionIndex); }});
  cancelQuizBtn.addEventListener('click', ()=> { if(confirm('Exit quiz? Your progress in this quiz will be lost.')) endQuiz(); });

  function showResults() {
    quizSection.classList.add('hidden'); resultsSection.classList.remove('hidden');
    let total = questionsToPractice.length; let correctCount = 0; const wrongList = [];
    questionsToPractice.forEach(q => { if(userAnswers[q.id]===q.answer) correctCount++; else wrongList.push(q); });
    resultsSummary.innerHTML = `<p>Total Questions: <strong>${total}</strong></p>
      <p>Correct Answers: <strong>${correctCount}</strong></p>
      <p>Accuracy: <strong>${Math.round(100*correctCount/total)}</strong>%</p>
      <p>Mode: <strong>${currentMode}</strong></p>
      <p>Category: <strong>${displayCategoryKey(currentCategoryKey)}</strong></p>`;
    if (wrongList.length > 0) {
      const info = document.createElement('p');
      info.innerHTML = `<em>Incorrect questions: <strong>${wrongList.length}</strong></em>`;
      resultsSummary.appendChild(info);
      const btn = document.createElement('button');
      btn.className = 'px-4 py-2 bg-blue-600 text-white rounded mt-2';
      btn.textContent = 'Re-practice Incorrect';
      // use a copy of the wrongList so closure keeps it safe
      btn.addEventListener('click', () => { startRepractice(wrongList.slice()); });
      resultsSummary.appendChild(btn);
    } else {
      if (inRepractice) inRepractice = false;
    }
  }

  function startRepractice(wrongQuestionsArray) {
    if(!Array.isArray(wrongQuestionsArray) || wrongQuestionsArray.length===0) return;
    inRepractice=true; currentMode='repractice';
    questionsToPractice = wrongQuestionsArray.slice();
    currentQuestionIndex=0; userAnswers={};
    resultsSection.classList.add('hidden'); quizSection.classList.remove('hidden');
    quizCatDisplay.textContent = displayCategoryKey(currentCategoryKey); quizModeDisplay.textContent = 'Re-practice Incorrect';
    setModeBadge(currentMode, true);
    showQuestion(currentQuestionIndex);
  }

  practiceWeakBtn.addEventListener('click', ()=> {
    if(!weakQuestions[currentCategoryKey] || weakQuestions[currentCategoryKey].length===0){ alert('No weak questions to practice.'); return; }
    inRepractice=false; currentMode='weak';
    questionsToPractice = prepareQuestionsByKey(currentCategoryKey,'weak'); currentQuestionIndex=0; userAnswers={};
    resultsSection.classList.add('hidden'); quizSection.classList.remove('hidden');
    quizCatDisplay.textContent=displayCategoryKey(currentCategoryKey); quizModeDisplay.textContent='Practice Weak Areas';
    setModeBadge(currentMode, false);
    showQuestion(currentQuestionIndex);
  });

  backToSetupBtn.addEventListener('click', ()=> { inRepractice=false; resultsSection.classList.add('hidden'); setupSection.classList.remove('hidden'); setModeBadge(null,false); });

  /* -------------------------
     Start Quiz (handles Random Mixed)
     ------------------------- */
  startQuizBtn.addEventListener('click', ()=> {
    const mode = quizModeSelect.value;
    currentMode = mode;
    if(mode === 'random_mixed') {
      const checked = Array.from(mixedSetsContainer.querySelectorAll('input[type="checkbox"].set-checkbox:checked'));
      if(checked.length === 0) { alert('Please select at least one set for Random Mixed mode.'); return; }
      let pool = [];
      checked.forEach(cb => {
        const key = cb.dataset.key;
        if(questionBank[key] && questionBank[key].length > 0) pool = pool.concat(questionBank[key]);
      });
      if(pool.length === 0) { alert('Selected sets contain no questions.'); return; }
      shuffleArray(pool);
      questionsToPractice = pool;
      currentCategoryKey = null;
      currentQuestionIndex = 0; userAnswers = {};
      setupSection.classList.add('hidden'); quizSection.classList.remove('hidden'); resultsSection.classList.add('hidden');
      quizCatDisplay.textContent = `Mixed (${checked.length} set(s))`; quizModeDisplay.textContent = 'Random Mixed';
      setModeBadge('random_mixed', true);
      showQuestion(currentQuestionIndex);
      return;
    }

    const main = quizMain.value && quizMain.value.trim() !== '' ? quizMain.value.trim() : '';
    const cls  = quizClass.value && quizClass.value.trim() !== '' ? quizClass.value.trim() : '';
    const chap = quizChapter.value && quizChapter.value.trim() !== '' ? quizChapter.value.trim() : '';
    const setv = quizSet.value && quizSet.value.trim() !== '' ? quizSet.value.trim() : '';

    if(!main && !cls && !chap && !setv) { alert('Please select at least one of Main / Class / Chapter / Set to start.'); return; }

    const matchingKeys = Object.keys(questionBank).filter(k => {
      const p = splitKey(k);
      if(main && p.main !== main) return false;
      if(cls  && p.cls  !== cls)  return false;
      if(chap && p.chap !== chap) return false;
      if(setv && p.set  !== setv)  return false;
      return true;
    });

    if(matchingKeys.length === 0) { alert('No questions available for the selected filters.'); return; }

    let pool = [];
    matchingKeys.forEach(k => {
      if(Array.isArray(questionBank[k])) pool = pool.concat(questionBank[k]);
    });

    // filter pool by mode if needed
    if(mode === 'weak') {
      const filtered = pool.filter(q => {
        const list = weakQuestions[q.category] || [];
        return list.includes(q.id);
      });
      pool = filtered;
    } else if(mode === 'bookmarked') {
      const filtered = pool.filter(q => {
        const list = bookmarkedQuestions[q.category] || [];
        return list.includes(q.id);
      });
      pool = filtered;
    } else if(mode === 'adaptive') {
      // keep as-is for now (could implement difficulty-based selection)
    } else if(mode === 'normal') {
      // nothing to do
    }

    if(pool.length === 0) { alert('No questions available for the selected filters and mode.'); return; }

    currentCategoryKey = matchingKeys.length === 1 ? matchingKeys[0] : null;

    questionsToPractice = pool.slice();
    shuffleArray(questionsToPractice);
    currentQuestionIndex = 0; userAnswers = {};

    setupSection.classList.add('hidden'); quizSection.classList.remove('hidden'); resultsSection.classList.add('hidden');

    if(currentCategoryKey) {
      quizCatDisplay.textContent = displayCategoryKey(currentCategoryKey);
    } else {
      const parts = [];
      if(main) parts.push(main);
      if(cls)  parts.push(cls);
      if(chap) parts.push(chap);
      if(setv) parts.push(setv);
      quizCatDisplay.textContent = parts.length ? parts.join(' â†’ ') : '(Multiple)';
    }

    quizModeDisplay.textContent = quizModeSelect.options[quizModeSelect.selectedIndex].text;
    setModeBadge(mode, false);
    showQuestion(currentQuestionIndex);
  });

  function endQuiz() { quizSection.classList.add('hidden'); setupSection.classList.remove('hidden'); resultsSection.classList.add('hidden'); setModeBadge(null,false); }

  /* -------------------------
     Display & cleanup utilities
     ------------------------- */
  function displayCategoryKey(key) { if(!key) return '(Mixed)'; const p = splitKey(key); return `${p.main} â†’ ${p.cls} â†’ ${p.chap} â†’ ${p.set}`; }
  function cleanupQuestionReferences(key, qid) {
    if(weakQuestions[key]) {
      const i = weakQuestions[key].indexOf(qid); if(i!==-1) weakQuestions[key].splice(i,1); if(weakQuestions[key].length===0) delete weakQuestions[key];
    }
    if(bookmarkedQuestions[key]) {
      const i = bookmarkedQuestions[key].indexOf(qid); if(i!==-1) bookmarkedQuestions[key].splice(i,1); if(bookmarkedQuestions[key].length===0) delete bookmarkedQuestions[key];
    }
  }
  function deleteQuestion(key, qid) {
    if(!questionBank[key]) return;
    if(!confirm('Delete this question? This cannot be undone.')) return;
    questionBank[key] = questionBank[key].filter(q=>q.id!==qid);
    cleanupQuestionReferences(key,qid);
    if(questionBank[key].length===0) { delete questionBank[key]; if(weakQuestions[key]) delete weakQuestions[key]; if(bookmarkedQuestions[key]) delete bookmarkedQuestions[key]; if(progressData[key]) delete progressData[key]; }
    saveToStorage(); buildUIAfterDataChange();
  }
  function deleteBranch(parts) {
    const m = parts.main||''; const c = parts.cls; const ch = parts.chap; const s = parts.set;
    if(!m) return;
    const prefixParts = s?4:(ch?3:(c?2:1));
    const prefix = [m,c||'',ch||'',s||''].slice(0,prefixParts).join(PATH_SEP);
    const keysToDelete = Object.keys(questionBank).filter(k => k.startsWith(prefix));
    if(keysToDelete.length===0) return;
    if(!confirm(`Delete ${keysToDelete.length} group(s) under this branch? This cannot be undone.`)) return;
    keysToDelete.forEach(k => {
      questionBank[k].forEach(q => cleanupQuestionReferences(k,q.id));
      delete questionBank[k];
      if(weakQuestions[k]) delete weakQuestions[k];
      if(bookmarkedQuestions[k]) delete bookmarkedQuestions[k];
      if(progressData[k]) delete progressData[k];
    });
    saveToStorage(); buildUIAfterDataChange();
  }

  /* -------------------------
     Manage panel rendering (hierarchical)
     ------------------------- */
  function renderManageCategories(filterText='') {
    // build into a fragment to minimize reflows
    manageCategoriesDiv.innerHTML='';
    const _mc_frag = document.createDocumentFragment();
    const tree = buildPathsIndex();
    const mains = Object.keys(tree).sort();
    if(mains.length===0) { manageCategoriesDiv.innerHTML = '<p class="text-gray-500">No categories available.</p>'; return; }
    mains.forEach(m => {
      const mainCount = Object.values(tree[m]).reduce((acc,c)=> { for(const ch in c) for(const s in c[ch]) acc += c[ch][s]; return acc; }, 0);
      const mainCard = document.createElement('div'); mainCard.className='border rounded p-3 bg-gray-50 dark:bg-gray-700';
      const mainHeader = document.createElement('div'); mainHeader.className='flex justify-between items-center mb-2';
      mainHeader.innerHTML = `<div class="font-semibold">${m} <span class="text-sm text-gray-500">(${mainCount})</span></div>`;
      const mainControls = document.createElement('div'); mainControls.className='flex gap-2';
      const expandMain = document.createElement('button'); expandMain.className='px-2 py-1 bg-gray-300 rounded'; expandMain.textContent='Expand';
      const delMain = document.createElement('button'); delMain.className='px-2 py-1 bg-red-500 text-white rounded'; delMain.textContent='Delete Main';
      mainControls.appendChild(expandMain); mainControls.appendChild(delMain); mainHeader.appendChild(mainControls); mainCard.appendChild(mainHeader);
      const mainContent = document.createElement('div'); mainContent.className='hidden pl-3';
      const classes = Object.keys(tree[m]).sort();
      classes.forEach(c => {
        const classRow = document.createElement('div'); classRow.className='border rounded p-2 my-2 bg-white dark:bg-gray-800';
        const classHeader = document.createElement('div'); classHeader.className='flex justify-between items-center mb-2';
        const classCount = Object.keys(tree[m][c]).reduce((acc,ch)=> acc + Object.values(tree[m][c][ch]).reduce((a,b)=> a+b,0),0);
        classHeader.innerHTML = `<div class="font-medium">${c} <span class="text-sm text-gray-500">(${classCount})</span></div>`;
        const classControls = document.createElement('div'); classControls.className='flex gap-2';
        const expandClass = document.createElement('button'); expandClass.className='px-2 py-1 bg-gray-200 rounded'; expandClass.textContent='Expand';
        const delClass = document.createElement('button'); delClass.className='px-2 py-1 bg-red-500 text-white rounded'; delClass.textContent='Delete Class';
        classControls.appendChild(expandClass); classControls.appendChild(delClass); classHeader.appendChild(classControls); classRow.appendChild(classHeader);
        const classContent = document.createElement('div'); classContent.className='hidden pl-3';
        const chapters = Object.keys(tree[m][c]).sort();
        chapters.forEach(ch => {
          const chapterRow = document.createElement('div'); chapterRow.className='mb-2';
          const chapterHeader = document.createElement('div'); chapterHeader.className='flex justify-between items-center mb-1';
          const chapterCount = Object.values(tree[m][c][ch]).reduce((a,b)=> a+b,0);
          chapterHeader.innerHTML = `<div>${ch} <span class="text-sm text-gray-500">(${chapterCount})</span></div>`;
          const chapterControls = document.createElement('div'); chapterControls.className='flex gap-2';
          const expandChap = document.createElement('button'); expandChap.className='px-2 py-1 bg-gray-200 rounded'; expandChap.textContent='Expand';
          const delChap = document.createElement('button'); delChap.className='px-2 py-1 bg-red-500 text-white rounded'; delChap.textContent='Delete Chapter';
          chapterControls.appendChild(expandChap); chapterControls.appendChild(delChap); chapterHeader.appendChild(chapterControls); chapterRow.appendChild(chapterHeader);
          const chapterContent = document.createElement('div'); chapterContent.className='hidden pl-3';
          const sets = Object.keys(tree[m][c][ch]).sort();
          sets.forEach(s => {
            const setRow = document.createElement('div'); setRow.className='border rounded p-2 mb-2 bg-gray-50 dark:bg-gray-800';
            setRow.innerHTML = `<div class="flex justify-between items-center mb-2"><div class="font-medium">${s} <span class="text-sm text-gray-500">(${tree[m][c][ch][s]})</span></div></div>`;
            const setControls = document.createElement('div'); setControls.className='flex gap-2 mb-2';
            const viewSetBtn = document.createElement('button'); viewSetBtn.className='px-2 py-1 bg-blue-500 text-white rounded'; viewSetBtn.textContent='View Questions';
            const delSetBtn = document.createElement('button'); delSetBtn.className='px-2 py-1 bg-red-500 text-white rounded'; delSetBtn.textContent='Delete Set';
            setControls.appendChild(viewSetBtn); setControls.appendChild(delSetBtn); setRow.appendChild(setControls);
            const qListDiv = document.createElement('div'); qListDiv.className='hidden mt-2'; setRow.appendChild(qListDiv);

            viewSetBtn.addEventListener('click', ()=> {
              if(qListDiv.classList.contains('hidden')) { renderQuestionsInSet(m,c,ch,s,qListDiv, manageSearch.value.trim()); qListDiv.classList.remove('hidden'); viewSetBtn.textContent='Hide Questions'; }
              else { qListDiv.classList.add('hidden'); viewSetBtn.textContent='View Questions'; }
            });
            delSetBtn.addEventListener('click', ()=> deleteBranch({ main:m, cls:c, chap:ch, set:s }));
            chapterContent.appendChild(setRow);
          });

          expandChap.addEventListener('click', ()=> { if(chapterContent.classList.contains('hidden')) { chapterContent.classList.remove('hidden'); expandChap.textContent='Collapse'; } else { chapterContent.classList.add('hidden'); expandChap.textContent='Expand'; } });
          delChap.addEventListener('click', ()=> deleteBranch({ main:m, cls:c, chap:ch }));
          chapterRow.appendChild(chapterContent); classContent.appendChild(chapterRow);
        });

        expandClass.addEventListener('click', ()=> { if(classContent.classList.contains('hidden')) { classContent.classList.remove('hidden'); expandClass.textContent='Collapse'; } else { classContent.classList.add('hidden'); expandClass.textContent='Expand'; } });
        delClass.addEventListener('click', ()=> deleteBranch({ main:m, cls:c }));
        classRow.appendChild(classContent); mainContent.appendChild(classRow);
      });

      expandMain.addEventListener('click', ()=> { if(mainContent.classList.contains('hidden')) { mainContent.classList.remove('hidden'); expandMain.textContent='Collapse'; } else { mainContent.classList.add('hidden'); expandMain.textContent='Expand'; } });
      delMain.addEventListener('click', ()=> deleteBranch({ main:m }));
      mainCard.appendChild(mainContent); _mc_frag.appendChild(mainCard);
    });
    manageCategoriesDiv.appendChild(_mc_frag);
  }

  function renderQuestionsInSet(main, cls, chap, setv, container, filter='') {
    // use fragment for list rendering
    container.innerHTML=''; const key = pathKey(main,cls,chap,setv); container.dataset.key = key; const arr = questionBank[key]||[];
    const _rq_frag = document.createDocumentFragment();
    const f = (filter||'').toLowerCase(); const filtered = arr.filter(q => !f || (q.question && q.question.toLowerCase().includes(f)) || (q.difficulty && q.difficulty.toLowerCase().includes(f)));
    if(filtered.length===0) { container.innerHTML = '<p class="text-gray-500">No matching questions.</p>'; return; }
    filtered.forEach(q => {
      const row = document.createElement('div'); row.className='flex justify-between items-start p-2 bg-white dark:bg-gray-800 border rounded mb-2';
      const left = document.createElement('div'); left.style.flex='1';
      left.innerHTML = `<div class="font-medium">${q.question}</div><div class="text-sm text-gray-500">Difficulty: ${q.difficulty}</div>`;
      const right = document.createElement('div'); right.className='flex gap-2 ml-3';
      const editBtn = document.createElement('button'); editBtn.className='px-2 py-1 bg-blue-500 text-white rounded'; editBtn.textContent='Edit';
      const delBtn = document.createElement('button'); delBtn.className='px-2 py-1 bg-red-500 text-white rounded'; delBtn.textContent='Delete';
      right.appendChild(editBtn); right.appendChild(delBtn);
      row.appendChild(left); row.appendChild(right); _rq_frag.appendChild(row);

      editBtn.addEventListener('click', ()=> {
        mainInput.value = main; classInput.value = cls; chapterInput.value = chap; setInput.value = setv; difficultyInput.value = q.difficulty;
        if(typeof questionInput !== 'undefined' && questionInput) questionInput.value = q.question;
        q.options.forEach((opt,i)=> { if(optionInputs[i]) optionInputs[i].value = opt; });
        if(mcqForm && mcqForm.elements && mcqForm.elements['correct']) {
          const radios = mcqForm.elements['correct']; for(let r of radios) r.checked = (parseInt(r.value,10) === q.answer);
        }
        document.getElementById('edit-id').value = q.id; window.scrollTo({ top: mcqForm.offsetTop - 20, behavior:'smooth' });
      });

      delBtn.addEventListener('click', ()=> deleteQuestion(key, q.id));
    });
    container.appendChild(_rq_frag);
  }

  /* -------------------------
     Manage panel controls
     ------------------------- */
  toggleManageBankBtn.addEventListener('click', ()=> {
    manageBankPanel.classList.toggle('hidden');


    if(!manageBankPanel.classList.contains('hidden')) renderManageCategories(manageSearch.value.trim());
  });
  refreshManageBtn.addEventListener('click', ()=> renderManageCategories(manageSearch.value.trim()));
  manageSearch.addEventListener('input', debounce(()=> renderManageCategories(manageSearch.value.trim()), 220));
  exportBankBtn.addEventListener('click', ()=> { importExportArea.value = JSON.stringify(questionBank,null,2); alert('Exported to import area.'); });

  importBankBtn.addEventListener('click', ()=> { populateImportPlacementOverlay(); impOverlay.classList.remove('hidden'); impOverlay.setAttribute('aria-hidden','false'); });

  function populateImportPlacementOverlay() {
    const tree = buildPathsIndex();
    impMainList.innerHTML=''; impClassList.innerHTML=''; impChapterList.innerHTML=''; impSetList.innerHTML='';
    Object.keys(tree).sort().forEach(m => impMainList.appendChild(new Option(m)));
    const classesSet = new Set(); const chapSet = new Set(); const setSet = new Set();
    for(const m in tree) {
      for(const c in tree[m]) classesSet.add(c);
      for(const c in tree[m]) { for(const ch in tree[m][c]) chapSet.add(ch); for(const ch in tree[m][c]) for(const s in tree[m][c][ch]) setSet.add(s); }
    }
    classesSet.forEach(c=> impClassList.appendChild(new Option(c))); chapSet.forEach(ch=> impChapterList.appendChild(new Option(ch))); setSet.forEach(s=> impSetList.appendChild(new Option(s)));
    impMain.value=''; impClass.value=''; impChapter.value=''; impSet.value='';
  }

  impCancel.addEventListener('click', ()=> { impOverlay.classList.add('hidden'); impOverlay.setAttribute('aria-hidden','true'); });

  impConfirm.addEventListener('click', ()=> {
    const main = impMain.value.trim(), cls = impClass.value.trim(), chap = impChapter.value.trim(), setv = impSet.value.trim();
    if(!main||!cls||!chap||!setv) { alert('Please fill Main, Class, Chapter and Set to place imported questions.'); return; }
    try {
      const data = JSON.parse(importExportArea.value);
      if(!data || typeof data!=='object') throw new Error('No valid JSON in import area.');
      const destKey = pathKey(main,cls,chap,setv);
      if(!questionBank[destKey]) questionBank[destKey]=[];
      let count=0;
      for(const k in data) {
        const arr = data[k];
        if(!Array.isArray(arr)) continue;
        arr.forEach(q => {
          const nq = Object.assign({}, q);
          if(!nq.id) nq.id = generateId();
          nq.category = destKey;
          if(!nq.options) nq.options = ['', '', '', ''];
          if(typeof nq.answer !== 'number') nq.answer = 0;
          questionBank[destKey].push(nq); count++;
        });
      }
      saveToStorage(); buildUIAfterDataChange(); impOverlay.classList.add('hidden'); impOverlay.setAttribute('aria-hidden','true'); alert(`Imported ${count} questions into ${main} â†’ ${cls} â†’ ${chap} â†’ ${setv}`);
    } catch(e) { alert('Import failed: ' + e.message); }
  });

  /* -------------------------
     Random Mixed: render set selection panel
     ------------------------- */
  function renderMixedSelectionPanel() {
    // build mixed panel into fragment to reduce DOM churn
    mixedSetsContainer.innerHTML = '';
    const _mx_frag = document.createDocumentFragment();
    const tree = buildPathsIndex();
    const mains = Object.keys(tree).sort();
    if(mains.length===0) { mixedSetsContainer.innerHTML = '<p class="text-gray-500">No sets available.</p>'; return; }
    mains.forEach(m => {
      const mDiv = document.createElement('div'); mDiv.className='pl-1';
      const mHeader = document.createElement('div'); mHeader.className='flex items-center justify-between';
      const mLeft = document.createElement('div'); mLeft.innerHTML = `<label><input type="checkbox" class="main-select mr-2"> <strong>${m}</strong></label>`;
      const mCount = document.createElement('div'); mCount.className='text-sm text-gray-600'; mCount.textContent = `(${Object.values(tree[m]).reduce((acc,c)=> { for(const ch in c) for(const s in c[ch]) acc += c[ch][s]; return acc; },0)})`;
      mHeader.appendChild(mLeft); mHeader.appendChild(mCount); mDiv.appendChild(mHeader);

      const classes = Object.keys(tree[m]).sort();
      const classesDiv = document.createElement('div'); classesDiv.className='pl-6';
      classes.forEach(c => {
        const cDiv = document.createElement('div'); cDiv.className='mb-1';
        const cHeader = document.createElement('div'); cHeader.className='flex items-center justify-between';
        const cLeft = document.createElement('div'); cLeft.innerHTML = `<label><input type="checkbox" class="class-select mr-2"> <span class="font-medium">${c}</span></label>`;
        const cCount = document.createElement('div'); cCount.className='text-sm text-gray-600'; cCount.textContent = `(${Object.keys(tree[m][c]).reduce((acc,ch)=> acc + Object.values(tree[m][c][ch]).reduce((a,b)=> a+b,0),0)})`;
        cHeader.appendChild(cLeft); cHeader.appendChild(cCount); cDiv.appendChild(cHeader);

        const chaptersDiv = document.createElement('div'); chaptersDiv.className='pl-6';
        Object.keys(tree[m][c]).sort().forEach(ch => {
          const chDiv = document.createElement('div'); chDiv.className='mb-1';
          const chHeader = document.createElement('div'); chHeader.className='flex items-center justify-between';
          const chLeft = document.createElement('div'); chLeft.innerHTML = `<label><input type="checkbox" class="chapter-select mr-2"> ${ch}</label>`;
          const chCount = document.createElement('div'); chCount.className='text-sm text-gray-600'; chCount.textContent = `(${Object.values(tree[m][c][ch]).reduce((a,b)=> a+b,0)})`;
          chHeader.appendChild(chLeft); chHeader.appendChild(chCount); chDiv.appendChild(chHeader);

          const setsDiv = document.createElement('div'); setsDiv.className='pl-6';
          Object.keys(tree[m][c][ch]).sort().forEach(s => {
            const sRow = document.createElement('div'); sRow.className='flex items-center justify-between';
            const checkbox = document.createElement('input'); checkbox.type='checkbox'; checkbox.className='set-checkbox mr-2'; checkbox.dataset.key = pathKey(m,c,ch,s);
            const label = document.createElement('label'); label.appendChild(checkbox); label.appendChild(document.createTextNode(`${s}`));
            const cnt = document.createElement('div'); cnt.className='text-sm text-gray-600'; cnt.textContent = `(${tree[m][c][ch][s]})`;
            sRow.appendChild(label); sRow.appendChild(cnt); setsDiv.appendChild(sRow);
          });

          chDiv.appendChild(setsDiv); chaptersDiv.appendChild(chDiv);
        });

        cDiv.appendChild(chaptersDiv); classesDiv.appendChild(cDiv);
      });

      mDiv.appendChild(classesDiv); _mx_frag.appendChild(mDiv);
    });
    mixedSetsContainer.appendChild(_mx_frag);

    // wire up select-all behaviors & enable start button when selections exist
    mixedSetsContainer.querySelectorAll('.main-select').forEach((mChk, mIdx) => {
      mChk.addEventListener('change', (e) => {
        // toggle all descendant checkboxes under this main
        const root = mChk.closest('div'); // top-level mainDiv
        const checkboxes = root.querySelectorAll('input.set-checkbox');
        checkboxes.forEach(cb => cb.checked = mChk.checked);
        updateStartButtonStateMixed();
      });
    });
    mixedSetsContainer.querySelectorAll('.class-select').forEach(cChk => {
      cChk.addEventListener('change', ()=> {
        const classRow = cChk.closest('div[ ]') || cChk.closest('div'); // find parent block
        const checkboxes = cChk.closest('div').querySelectorAll('input.set-checkbox');
        // To ensure we toggle only that class, find the next siblings (we rely on structure)
        // Simpler: toggle all descendant set-checkbox inside the closest outer container
        let parent = cChk.closest('div'); // might be header
        // find sets within same class by climbing to parent with class 'pl-6' (classesDiv)
        // Instead, do: find following sibling nodes within the same classDiv
        // We'll just toggle descendant set-checkboxes in the nearest parent with pl-6 two levels up
        const classContainer = cChk.closest('.pl-6') || cChk.parentElement.parentElement;
        if(classContainer) {
          const descendantSets = classContainer.querySelectorAll('input.set-checkbox');
          descendantSets.forEach(cb => cb.checked = cChk.checked);
        }
        updateStartButtonStateMixed();
      });
    });
    mixedSetsContainer.querySelectorAll('.chapter-select').forEach(chk => {
      chk.addEventListener('change', ()=> {
        // toggle descendant set-checkboxes under the same chapter
        const chapterContainer = chk.closest('.pl-6') || chk.parentElement.parentElement;
        if(chapterContainer) {
          const descendantSets = chapterContainer.querySelectorAll('input.set-checkbox');
          descendantSets.forEach(cb => cb.checked = chk.checked);
        }
        updateStartButtonStateMixed();
      });
    });

    // When any individual set checkbox toggles, update Start button state (debounced to avoid thrash)
    const _updStartDeb = debounce(()=> updateStartButtonStateMixed(), 100);
    mixedSetsContainer.querySelectorAll('input.set-checkbox').forEach(cb => cb.addEventListener('change', ()=> _updStartDeb()));

    // ensure start button disabled by default
    updateStartButtonStateMixed();
  }

  function updateStartButtonStateMixed() {
    if(quizModeSelect.value !== 'random_mixed') { startQuizBtn.disabled = false; return; }
    const anyChecked = mixedSetsContainer.querySelectorAll('input.set-checkbox:checked').length > 0;
    startQuizBtn.disabled = !anyChecked;
  }

  /* -------------------------
     Mode badge helper
     ------------------------- */
  function setModeBadge(mode, isMixed) {
    modeBadgeHolder.innerHTML = '';
    if(mode === 'random_mixed' || isMixed) {
      const span = document.createElement('span'); span.className = 'badge'; span.textContent = 'Random Mixed Mode';
      modeBadgeHolder.appendChild(span);
    }
  }

  /* -------------------------
     Build UI after data changes
     ------------------------- */
  function buildUIAfterDataChange() {
    fillDatalistsAndQuizSelectors();
    renderManageCategories(manageSearch.value.trim());
    // If mixed panel currently visible, re-render it to update counts and keys
    if(!mixedPanel.classList.contains('hidden')) renderMixedSelectionPanel();
  }

  /* -------------------------
     Initial load & sample data
     ------------------------- */
  loadFromStorage(); loadTheme();
  // schedule UI build after initial parsing/idle to speed up first paint
  if (window.requestIdleCallback) requestIdleCallback(buildUIAfterDataChange, {timeout: 500}); else setTimeout(buildUIAfterDataChange, 60);
  if(Object.keys(questionBank).length===0) {
    const k = pathKey('English','General','General','Default');
    questionBank[k] = [
      { id: generateId(), category:k, difficulty:'easy', question:'Which is the correct spelling?', options:['Recieve','Receive','Recive','Receve'], answer:1 },
      { id: generateId(), category:k, difficulty:'medium', question:'Choose the correctly spelled word:', options:['Accomodate','Acommodate','Accommodate','Acomodate'], answer:2 },
      { id: generateId(), category:k, difficulty:'hard', question:'Select the correct spelling:', options:['Conscience','Consciense','Conscence','Consience'], answer:0 }
    ];
    saveToStorage(); buildUIAfterDataChange();
  }

  /* -------------------------
     Quiz cascades handlers
     ------------------------- */
 
/* ---- Export modal logic injected ---- */
try {
  // DOM refs inside IIFE
  const exportOverlay = document.getElementById('export-overlay');
  const expMain = document.getElementById('exp-main');
  const expClass = document.getElementById('exp-class');
  const expChap = document.getElementById('exp-chapter');
  const expSet = document.getElementById('exp-set');
  const expAllBtn = document.getElementById('exp-all');
  const expSelBtn = document.getElementById('exp-selected');
  const expBranchBtn = document.getElementById('exp-branch');
  const expCancelBtn = document.getElementById('exp-cancel');

  function openExportOverlay(){
    buildExportSelectors();
    exportOverlay.classList.remove('hidden');
    exportOverlay.setAttribute('aria-hidden','false');
  }
  function closeExportOverlay(){
    exportOverlay.classList.add('hidden');
    exportOverlay.setAttribute('aria-hidden','true');
  }

  function fillSelect(sel, items, placeholder){
    sel.innerHTML = '';
    const opt = document.createElement('option'); opt.value=''; opt.textContent = placeholder; sel.appendChild(opt);
    items.forEach(it => { const o = document.createElement('option'); o.value = it; o.textContent = it; sel.appendChild(o); });
  }

  function buildExportSelectors(){
    const tree = buildPathsIndex();
    const mains = Object.keys(tree).sort();
    // aggregate lists for modal initial view
    const classesSet = new Set(), chaptersSet = new Set(), setsSet = new Set();
    for (const m in tree) {
      for (const c in tree[m]) classesSet.add(c);
      for (const c in tree[m]) {
        for (const ch in tree[m][c]) chaptersSet.add(ch);
        for (const ch in tree[m][c]) for (const s in tree[m][c][ch]) setsSet.add(s);
      }
    }
    fillSelect(expMain, mains, 'Select Main');
    updateSelectWithCounts(expMain, 'main');
    fillSelect(expClass, Array.from(classesSet).sort(), 'Select Class');
    updateSelectWithCounts(expClass, 'class');
    fillSelect(expChap, Array.from(chaptersSet).sort(), 'Select Chapter');
    updateSelectWithCounts(expChap, 'chapter');
    fillSelect(expSet, Array.from(setsSet).sort(), 'Select Set');
    updateSelectWithCounts(expSet, 'set');

    expMain.onchange = () => {
      const m = expMain.value;
      if(!m){ fillSelect(expClass, [], 'Select Class');
    updateSelectWithCounts(expClass, 'class', expMain.value); return; }
      fillSelect(expClass, Object.keys(tree[m]||{}).sort(), 'Select Class');
      updateSelectWithCounts(expClass, 'class', expMain.value);
      fillSelect(expChap, [], 'Select Chapter');
      updateSelectWithCounts(expChap, 'chapter', expMain.value, expClass.value);
      fillSelect(expSet, [], 'Select Set');
      updateSelectWithCounts(expSet, 'set', expMain.value, expClass.value, expChap.value);
    };
    expClass.onchange = () => {
      const m = expMain.value, c = expClass.value;
      if(!m||!c){ fillSelect(expChap, [], 'Select Chapter');
    updateSelectWithCounts(expChap, 'chapter', expMain.value, expClass.value); return; }
      fillSelect(expChap, Object.keys(tree[m][c]||{}).sort(), 'Select Chapter');
      updateSelectWithCounts(expChap, 'chapter', expMain.value, expClass.value);
      fillSelect(expSet, [], 'Select Set');
      updateSelectWithCounts(expSet, 'set', expMain.value, expClass.value, expChap.value);
    };
    expChap.onchange = () => {
      const m = expMain.value, c = expClass.value, ch = expChap.value;
      if(!m||!c||!ch){ fillSelect(expSet, [], 'Select Set');
    updateSelectWithCounts(expSet, 'set', expMain.value, expClass.value, expChap.value); return; }
      fillSelect(expSet, Object.keys(tree[m][c][ch]||{}).sort(), 'Select Set');
      updateSelectWithCounts(expSet, 'set', expMain.value, expClass.value, expChap.value);
    };
  }

  function writeToTextarea(obj){
    try {
      document.getElementById('import-export-area').value = JSON.stringify(obj, null, 2);
      showToast('Exported to Import / Export area', 'success');
    } catch(e){
      alert('Export failed: ' + e.message);
    }
    closeExportOverlay();
  }

  // Export behaviors:
  expAllBtn.addEventListener('click', () => {
    writeToTextarea(questionBank);
  });

  expSelBtn.addEventListener('click', () => {
    const m = expMain.value, c = expClass.value, ch = expChap.value, s = expSet.value;
    if(!m || !c || !ch || !s){ showToast('Select Main, Class, Chapter and Set for Selected export','warn'); return; }
    const key = pathKey(m,c,ch,s);
    if(!questionBank[key]){ showToast('No questions for selected key','warn'); return; }
    const out = {}; out[key] = questionBank[key];
    writeToTextarea(out);
  });

  expBranchBtn.addEventListener('click', () => {
    const m = expMain.value, c = expClass.value, ch = expChap.value, s = expSet.value;
    let prefix = '';
    if(m) prefix = m;
    if(c) prefix += PATH_SEP + c;
    if(ch) prefix += PATH_SEP + ch;
    if(s) prefix += PATH_SEP + s;
    if(!prefix){ showToast('Select at least a Main to export branch','warn'); return; }
    const out = {};
    Object.keys(questionBank).forEach(k => { if(k.startsWith(prefix)) out[k] = questionBank[k]; });
    if(Object.keys(out).length === 0){ showToast('No matching sets for branch','warn'); return; }
    writeToTextarea(out);
  });

  expCancelBtn.addEventListener('click', closeExportOverlay);

  // Replace existing export button behavior to use this overlay and to also support exporting the current quiz pool
  try {
    if(typeof exportBankBtn !== 'undefined' && exportBankBtn) {
      exportBankBtn.removeEventListener && exportBankBtn.removeEventListener('click', ()=>{});
      exportBankBtn.addEventListener('click', (ev) => {
        ev.preventDefault();
        // If a quiz is running (questionsToPractice exists), export that pool grouped by category.
        if(Array.isArray(questionsToPractice) && questionsToPractice.length > 0) {
          const grouped = {};
          questionsToPractice.forEach(q => {
            const k = q.category || q.category;
            if(!grouped[k]) grouped[k] = [];
            grouped[k].push(q);
          });
          writeToTextarea(grouped);
          return;
        }
        // If Random Mixed mode is selected and mixed panel has selections, export selected sets
        if(quizModeSelect && quizModeSelect.value === 'random_mixed') {
          const checked = Array.from(mixedSetsContainer.querySelectorAll('input.set-checkbox:checked')).map(i=>i.dataset.key);
          if(checked.length > 0) {
            const out = {};
            checked.forEach(k => { if(questionBank[k]) out[k] = questionBank[k]; });
            if(Object.keys(out).length>0) { writeToTextarea(out); return; }
          }
        }
        // Else, if setup selectors are filled, export that exact category
        const main = quizMain.value, cls = quizClass.value, chap = quizChapter.value, setv = quizSet.value;
        if(main && cls && chap && setv) {
          const key = pathKey(main, cls, chap, setv);
          if(questionBank[key]) { const obj={}; obj[key]=questionBank[key]; writeToTextarea(obj); return; }
        }
        // Otherwise, open overlay to let user choose
        openExportOverlay();
      });
    } else {
      // fallback: bind to element id
      const btn = document.getElementById('export-bank');
      if(btn){
        btn.addEventListener('click', (ev) => { ev.preventDefault(); openExportOverlay(); });
      }
    }
  } catch(e){
    // swallow errors to avoid breaking app init
    console.warn('Export overlay init error', e);
  }
} catch(e){
  console.warn('Export overlay not initialized', e);
}
 quizMain.addEventListener('change', ()=> { populateQuizCascadesForMain(quizMain.value); });
  quizClass.addEventListener('change', ()=> { populateQuizCascadesForClass(quizMain.value, quizClass.value); });
  quizChapter.addEventListener('change', ()=> { populateQuizCascadesForChapter(quizMain.value, quizClass.value, quizChapter.value); });

  /* -------------------------
     Show/hide mixed panel when mode changes
     ------------------------- */
  quizModeSelect.addEventListener('change', ()=> {
    const mode = quizModeSelect.value;
    if(mode === 'random_mixed') {
      mixedPanel.classList.remove('hidden');
      renderMixedSelectionPanel();
      // Start disabled until selection made
      startQuizBtn.disabled = true;
    } else {
      mixedPanel.classList.add('hidden');
      // ensure start enabled
      startQuizBtn.disabled = false;
      // reset any selection UI (rendering will reset on next mixed open)
      mixedSetsContainer.innerHTML = '';
      setModeBadge(null,false);
    }
  });

  /* -------------------------
     Helper to refresh UI manually
     ------------------------- */
  document.getElementById('refresh-manage').addEventListener('click', ()=> buildUIAfterDataChange());

})();
</script>
<div id="toast-container"></div><script>
/* ===== Helper: Toast messages ===== */
function showToast(message, type='info', duration=3000) {
  const tc = document.getElementById('toast-container');
  if(!tc) return;
  const div = document.createElement('div');
  div.className = 'toast ' + (type==='success' ? 'success' : (type==='warn' ? 'warn' : 'info'));
  div.textContent = message;
  tc.appendChild(div);
  setTimeout(()=> {
    div.style.transition = 'opacity 0.3s ease, transform 0.3s ease';
    div.style.opacity = '0';
    div.style.transform = 'translateY(8px)';
    setTimeout(()=> div.remove(), 350);
  }, duration);
}

/* ===== Backup Now (manual) ===== */
function backupNow() {
  try {
    const data = localStorage.getItem('mcqQuestions') || JSON.stringify({});
    const now = new Date();
    const pad = n => n.toString().padStart(2,'0');
    const fname = `quiz_backup_${now.getFullYear()}-${pad(now.getMonth()+1)}-${pad(now.getDate())}_${pad(now.getHours())}-${pad(now.getMinutes())}-${pad(now.getSeconds())}.json`;
    const blob = new Blob([data], {type: 'application/json'});
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = fname; document.body.appendChild(a); a.click();
    a.remove(); URL.revokeObjectURL(url);
    showToast('âœ… Backup saved as ' + fname, 'success', 3500);
  } catch(e) {
    showToast('Backup failed: ' + e.message, 'warn', 4000);
  }
}

/* ===== Flexible Import trigger ===== */
function openFlexibleImport() {
  // Ensure user has pasted JSON in import area
  const txt = document.getElementById('import-export-area').value.trim();
  if(!txt) {
    showToast('Paste JSON into Import / Export area first then click Flexible Import.', 'info', 3500);
    // open panel to help user
    document.getElementById('manage-search').focus();
    return;
  }
  // Parse lightly to count questions (best-effort)
  let count = 0;
  try {
    const parsed = JSON.parse(txt);
    if(Array.isArray(parsed)) count = parsed.length;
    else if(typeof parsed === 'object') {
      // If mapping keys to arrays, sum arrays
      for(const k in parsed) {
        if(Array.isArray(parsed[k])) count += parsed[k].length;
        else if(Array.isArray(parsed)) count += parsed.length;
      }
      // fallback: if it looks like a single question object
      if(count===0 && Object.keys(parsed).length>0 && parsed.question) count = 1;
    }
  } catch(e) {
    showToast('Invalid JSON: please fix and try again.', 'warn', 3500);
    return;
  }
  // prefill import overlay defaults (user still chooses destination)
  document.getElementById('imp-main').value = '';
  document.getElementById('imp-class').value = '';
  document.getElementById('imp-chapter').value = '';
  document.getElementById('imp-set').value = '';
  // show overlay
  const imp = document.getElementById('import-placement-overlay');
  if(imp) { imp.classList.remove('hidden'); imp.setAttribute('aria-hidden', 'false'); }
  showToast('Found ' + count + ' questions. Choose where to import.', 'info', 3500);
}

/* ===== Progress bar update ===== */
function updateProgressBar(index, total) {
  const fill = document.getElementById('progress-fill');
  if(!fill) return;
  const percent = total>0 ? Math.round(((index+1)/total)*100) : 0;
  fill.style.width = percent + '%';
  // color thresholds: green (>66), yellow (33-66), red (<33)
  if(percent >= 66) fill.style.background = '#16a34a'; // green
  else if(percent >= 33) fill.style.background = '#f59e0b'; // yellow
  else fill.style.background = '#ef4444'; // red
}

/* ===== Wire up new buttons ===== */
document.addEventListener('DOMContentLoaded', function(){
  const flex = document.getElementById('flex-import-btn');
  const backup = document.getElementById('backup-btn');
  if(flex) flex.addEventListener('click', openFlexibleImport);
  if(backup) backup.addEventListener('click', backupNow);

  // ensure impOverlay lists are filled if present (reuse existing function if available)
  if(typeof populateImportPlacementOverlay === 'function') {
    // no-op here, will be called when user clicks import bank
  }
});

// ===== Enhanced Manage MCQs Bank =====
function renderCategoryQuestions(categoryKey, container) {
  const mcqs = mcqBank[categoryKey] || [];
  let html = '<div style="margin-top:6px;">'
           + '<button onclick="deleteSelectedMCQs(\''+categoryKey+'\')">Delete Selected</button> '
           + '<label><input type="checkbox" onchange="toggleSelectAll(this, \'sel_'+categoryKey+'\')"> Select All</label>'
           + '</div>';
  html += '<ul style="list-style:none;padding:0;margin:0;">';
  mcqs.forEach((q, idx) => {
    html += '<li style="margin-bottom:4px;border:1px solid #ccc;padding:4px;">';
    html += '<input type="checkbox" class="sel_'+categoryKey+'" data-idx="'+idx+'"> ';
    html += '<span>'+escapeHTML(q.question)+'</span> ';
    html += '<button onclick="editMCQ(\''+categoryKey+'\','+idx+')">Edit</button> ';
    html += '<button onclick="deleteMCQ(\''+categoryKey+'\','+idx+')">Delete</button>';
    html += '</li>';
  });
  html += '</ul>';
  container.innerHTML = html;
}

function toggleSelectAll(master, cls) {
  document.querySelectorAll('.'+cls).forEach(cb => cb.checked = master.checked);
}

function deleteSelectedMCQs(categoryKey) {
  const checkboxes = document.querySelectorAll('.sel_'+categoryKey+':checked');
  if (checkboxes.length === 0) { alert('No MCQs selected'); return; }
  if (!confirm('Delete '+checkboxes.length+' MCQs?')) return;
  const toDelete = Array.from(checkboxes).map(cb => parseInt(cb.dataset.idx)).sort((a,b)=>b-a);
  toDelete.forEach(idx => { mcqBank[categoryKey].splice(idx, 1); });
  saveMCQBank();
  const container = document.getElementById('catq_'+categoryKey);
  if (container) renderCategoryQuestions(categoryKey, container);
}

function deleteMCQ(categoryKey, idx) {
  if (!confirm('Delete this MCQ?')) return;
  mcqBank[categoryKey].splice(idx,1);
  saveMCQBank();
  const container = document.getElementById('catq_'+categoryKey);
  if (container) renderCategoryQuestions(categoryKey, container);
}

function editMCQ(categoryKey, idx) {
  const q = mcqBank[categoryKey][idx];
  const container = document.getElementById('catq_'+categoryKey);
  let formHtml = '<div style="border:1px solid #666;padding:4px;">';
  formHtml += 'Question: <input type="text" id="edit_q" value="'+escapeHTML(q.question)+'" style="width:80%"><br>';
  q.options.forEach((opt,i)=>{
    formHtml += 'Option '+String.fromCharCode(65+i)+': <input type="text" id="edit_o'+i+'" value="'+escapeHTML(opt)+'" style="width:70%"><br>';
  });
  formHtml += 'Correct Answer: <select id="edit_ans">';
  q.options.forEach((opt,i)=>{
    formHtml += '<option value="'+i+'"'+(i===q.answer?' selected':'')+'>'+String.fromCharCode(65+i)+'</option>';
  });
  formHtml += '</select><br>';
  formHtml += '<button onclick="saveMCQEdit(\''+categoryKey+'\','+idx+')">Save</button> ';
  formHtml += '<button onclick="renderCategoryQuestions(\''+categoryKey+'\', document.getElementById(\'catq_'+categoryKey+'\'))">Cancel</button>';
  formHtml += '</div>';
  container.innerHTML = formHtml;
}

function saveMCQEdit(categoryKey, idx) {
  const qtext = document.getElementById('edit_q').value.trim();
  const opts = [0,1,2,3].map(i=>document.getElementById('edit_o'+i).value.trim());
  const ans = parseInt(document.getElementById('edit_ans').value);
  mcqBank[categoryKey][idx] = {
    ...mcqBank[categoryKey][idx],
    question: qtext,
    options: opts,
    answer: ans
  };
  saveMCQBank();
  const container = document.getElementById('catq_'+categoryKey);
  if (container) renderCategoryQuestions(categoryKey, container);
}

// Escape HTML utility
function escapeHTML(str) {
  return str.replace(/[&<>"']/g, function(m) {
    return {'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#039;'}[m];
  });
}

// Clean Export Handler to prevent mixing old exports
if (document.getElementById('export-bank')) {
    document.getElementById('export-bank').addEventListener('click', (e) => {
        e.preventDefault();
        const exportArea = document.getElementById('import-export-area');
        exportArea.value = ''; // clear old content
        
        // Determine export source based on current quiz state
        if (typeof questionsToPractice !== 'undefined' && Array.isArray(questionsToPractice) && questionsToPractice.length > 0) {
            // Export active quiz pool
            const out = {};
            questionsToPractice.forEach(q => {
                if (!out[q.key]) out[q.key] = [];
                out[q.key].push(q);
            });
            exportArea.value = JSON.stringify(out, null, 2);
            showToast('Exported current quiz pool');
            return;
        }

        // Check Random Mixed mode
        if (quizModeSelect && quizModeSelect.value === 'randomMixed' && mixedSetsContainer) {
            const selectedSets = Array.from(mixedSetsContainer.querySelectorAll('input[type=checkbox]:checked')).map(cb => cb.value);
            if (selectedSets.length > 0) {
                const out = {};
                selectedSets.forEach(setKey => {
                    if (questionBank[setKey]) out[setKey] = questionBank[setKey];
                });
                exportArea.value = JSON.stringify(out, null, 2);
                showToast('Exported Random Mixed sets');
                return;
            }
        }

        // Else export based on category selectors
        if (mainCatSelect && classSelect && chapterSelect && setSelect &&
            mainCatSelect.value && classSelect.value && chapterSelect.value && setSelect.value) {
            const key = pathKey(mainCatSelect.value, classSelect.value, chapterSelect.value, setSelect.value);
            if (questionBank[key]) {
                exportArea.value = JSON.stringify({[key]: questionBank[key]}, null, 2);
                showToast('Exported selected category');
                return;
            }
        }

        // Default: export full bank
        exportArea.value = JSON.stringify(questionBank, null, 2);
        showToast('Exported entire question bank');
    });
}

</script>
<!-- Manage Popup Overlay (dynamically move ONLY the Add/Update form (#mcq-form) into this for editing during quiz) -->
<div id="manage-popup-overlay" class="hidden fixed inset-0 bg-black bg-opacity-40 flex items-start justify-center z-50">
  <div id="manage-popup-modal" class="mt-12 w-full max-w-4xl bg-white dark:bg-gray-800 rounded shadow-lg overflow-auto" style="max-height:85vh;">
    <div class="flex items-center justify-between p-3 border-b">
      <div class="font-semibold">Manage Questions (Popup)</div>
      <button id="manage-popup-close" class="px-3 py-1 bg-red-600 text-white rounded" title="Close">Ã—</button>
    </div>
    <div id="manage-popup-host" class="p-4">
      <!-- Only the Add / Update form (#mcq-form) will be moved here dynamically -->
    </div>
  </div>
</div>


<script>
/* ===========================
   Google Drive Sync (Simple)
   ===========================
   âœ… What you must do:
   1) Create Google Cloud project
   2) Enable "Google Drive API"
   3) Create OAuth Client ID (Web application)
   4) Paste your CLIENT_ID below

   NOTE: This works best when you host this HTML (GitHub Pages/Netlify).
   If you open file as file://, Google login may be blocked by browser.
*/

const GDRIVE = {
  CLIENT_ID: "PASTE_YOUR_GOOGLE_OAUTH_CLIENT_ID_HERE",
  SCOPES: "https://www.googleapis.com/auth/drive.file",
  FILE_NAME: "PersonalQuizBank.json",
  tokenClient: null,
  accessToken: null
};

function gdriveSetStatus(msg){
  const el = document.getElementById("gdrive-status");
  if(el) el.textContent = "Drive: " + msg;
}

function gdriveEnsureToken(callback){
  if (GDRIVE.accessToken){
    callback();
    return;
  }
  if(!GDRIVE.tokenClient){
    GDRIVE.tokenClient = google.accounts.oauth2.initTokenClient({
      client_id: GDRIVE.CLIENT_ID,
      scope: GDRIVE.SCOPES,
      callback: (resp) => {
        if(resp && resp.access_token){
          GDRIVE.accessToken = resp.access_token;
          gdriveSetStatus("Connected âœ…");
          callback();
        } else {
          gdriveSetStatus("Login failed âŒ");
        }
      }
    });
  }
  gdriveSetStatus("Waiting for Google login...");
  GDRIVE.tokenClient.requestAccessToken({prompt: "consent"});
}

async function gdriveFindFileId(){
  const q = encodeURIComponent(`name='${GDRIVE.FILE_NAME}' and trashed=false`);
  const url = `https://www.googleapis.com/drive/v3/files?q=${q}&fields=files(id,name,modifiedTime)`;
  const res = await fetch(url, {
    headers: { Authorization: "Bearer " + GDRIVE.accessToken }
  });
  const data = await res.json();
  if(data.files && data.files.length) return data.files[0].id;
  return null;
}

async function gdriveUploadBank(){
  gdriveEnsureToken(async () => {
    try{
      gdriveSetStatus("Uploading...");
      const bank = (typeof questionBank !== 'undefined') ? questionBank : (window.getAllBankData ? window.getAllBankData() : null);
      if(!bank){
        alert("Export function not found in this build. I can wire it to your exact data store if needed.");
        gdriveSetStatus("Upload failed âŒ");
        return;
      }

      const fileId = await gdriveFindFileId();
      const boundary = "-------314159265358979323846";
      const metadata = { name: GDRIVE.FILE_NAME, mimeType: "application/json" };
      const multipartBody =
        `--${boundary}\r\n` +
        `Content-Type: application/json; charset=UTF-8\r\n\r\n` +
        `${JSON.stringify(metadata)}\r\n` +
        `--${boundary}\r\n` +
        `Content-Type: application/json\r\n\r\n` +
        `${JSON.stringify(bank)}\r\n` +
        `--${boundary}--`;

      let uploadUrl;
      let method;
      if(fileId){
        uploadUrl = `https://www.googleapis.com/upload/drive/v3/files/${fileId}?uploadType=multipart`;
        method = "PATCH";
      } else {
        uploadUrl = `https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart`;
        method = "POST";
      }

      const res = await fetch(uploadUrl, {
        method,
        headers: {
          Authorization: "Bearer " + GDRIVE.accessToken,
          "Content-Type": "multipart/related; boundary=" + boundary
        },
        body: multipartBody
      });

      if(!res.ok){
        const t = await res.text();
        console.error(t);
        alert("Upload failed. Check console for details.");
        gdriveSetStatus("Upload failed âŒ");
        return;
      }

      gdriveSetStatus("Uploaded âœ… (" + new Date().toLocaleString() + ")");
      alert("Uploaded to Google Drive âœ…\nFile: " + GDRIVE.FILE_NAME);
    } catch(e){
      console.error(e);
      gdriveSetStatus("Upload error âŒ");
      alert("Upload error: " + e.message);
    }
  });
}

async function gdriveDownloadBank(){
  gdriveEnsureToken(async () => {
    try{
      gdriveSetStatus("Downloading...");
      const fileId = await gdriveFindFileId();
      if(!fileId){
        alert("No bank file found on Drive yet. First upload from any device.");
        gdriveSetStatus("No file found");
        return;
      }

      const url = `https://www.googleapis.com/drive/v3/files/${fileId}?alt=media`;
      const res = await fetch(url, { headers: { Authorization: "Bearer " + GDRIVE.accessToken }});
      if(!res.ok){
        alert("Download failed.");
        gdriveSetStatus("Download failed âŒ");
        return;
      }

      const bank = await res.json();

      // Apply bank to local storage using existing importer if available
      if(typeof questionBank !== 'undefined'){
        questionBank = bank;
        if(typeof saveQuestionBank === 'function') saveQuestionBank();
      } else if(window.applyImportedBankData){
        window.applyImportedBankData(bank);
      } else if(window.setAllBankData){
        window.setAllBankData(bank);
      } else {
        alert("Import function not found in this build. I can wire it to your exact data store if needed.");
        gdriveSetStatus("Download imported? unknown");
        return;
      }

      gdriveSetStatus("Downloaded + Applied âœ… (" + new Date().toLocaleString() + ")");
      alert("Downloaded from Google Drive âœ…\nBank updated on this device.");
      if(window.refreshManageBankUI) window.refreshManageBankUI();
    } catch(e){
      console.error(e);
      gdriveSetStatus("Download error âŒ");
      alert("Download error: " + e.message);
    }
  });
}

document.addEventListener("DOMContentLoaded", () => {
  const signIn = document.getElementById("gdrive-signin");
  const up = document.getElementById("gdrive-upload");
  const down = document.getElementById("gdrive-download");

  if(signIn) signIn.addEventListener("click", () => gdriveEnsureToken(()=>{}));
  if(up) up.addEventListener("click", gdriveUploadBank);
  if(down) down.addEventListener("click", gdriveDownloadBank);

  gdriveSetStatus("Not connected");
});
</script>

</body>
</html>